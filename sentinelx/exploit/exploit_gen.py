from __future__ import annotations
import asyncio
import subprocess
import tempfile
import os
from typing import Dict, Any, List, Optional
from ..core.task import Task

try:
    from pwn import *
    import angr
    PWN_AVAILABLE = True
except ImportError:
    PWN_AVAILABLE = False


class AutoPwn(Task):
    """Automated binary exploitation using symbolic execution and pattern matching."""
    
    async def validate_params(self) -> None:
        """Validate AutoPwn parameters."""
        if not PWN_AVAILABLE:
            raise ValueError("pwntools and angr are required. Install with: pip install pwntools angr")
        
        if not self.params.get("binary"):
            raise ValueError("binary parameter is required")
        
        binary_path = self.params["binary"]
        if not os.path.exists(binary_path):
            raise ValueError(f"Binary file not found: {binary_path}")
    
    async def run(self) -> Dict[str, Any]:
        """Run automated exploitation."""
        await self.validate_params()
        
        binary_path = self.params["binary"]
        strategy = self.params.get("strategy", "symbolic")
        target_string = self.params.get("target", b"flag")
        timeout = self.params.get("timeout", 300)  # 5 minutes default
        
        results = {
            "binary": binary_path,
            "strategy": strategy,
            "status": "analyzing",
            "vulnerabilities": [],
            "exploits": []
        }
        
        try:
            # Basic binary analysis
            elf = ELF(binary_path)
            results["arch"] = elf.arch
            results["bits"] = elf.bits
            results["endian"] = elf.endian
            results["canary"] = elf.canary
            results["nx"] = elf.nx
            results["pie"] = elf.pie
            results["relro"] = elf.relro
            
            self.logger.info(f"Analyzing binary: {binary_path}")
            self.logger.info(f"Architecture: {elf.arch}, Bits: {elf.bits}")
            self.logger.info(f"Protections: Canary={elf.canary}, NX={elf.nx}, PIE={elf.pie}, RELRO={elf.relro}")
            
            if strategy == "symbolic":
                exploit_result = await self._symbolic_execution(binary_path, target_string, timeout)
                results.update(exploit_result)
            elif strategy == "fuzzing":
                exploit_result = await self._fuzzing_approach(binary_path, timeout)
                results.update(exploit_result)
            elif strategy == "pattern":
                exploit_result = await self._pattern_analysis(binary_path)
                results.update(exploit_result)
            else:
                # Try all strategies
                for strat in ["pattern", "fuzzing", "symbolic"]:
                    try:
                        if strat == "symbolic":
                            exploit_result = await self._symbolic_execution(binary_path, target_string, timeout // 3)
                        elif strat == "fuzzing":
                            exploit_result = await self._fuzzing_approach(binary_path, timeout // 3)
                        else:
                            exploit_result = await self._pattern_analysis(binary_path)
                        
                        if exploit_result.get("status") == "pwned":
                            results.update(exploit_result)
                            break
                    except Exception as e:
                        self.logger.warning(f"Strategy {strat} failed: {e}")
                        continue
            
            return results
            
        except Exception as e:
            self.logger.error(f"AutoPwn failed: {e}")
            return {
                "status": "error",
                "error": str(e),
                "binary": binary_path
            }
    
    async def _symbolic_execution(self, binary_path: str, target: bytes, timeout: int) -> Dict[str, Any]:
        """Use angr for symbolic execution to find vulnerabilities."""
        try:
            self.logger.info("Starting symbolic execution analysis...")
            
            # Load the binary
            proj = angr.Project(binary_path, load_options={"auto_load_libs": False})
            
            # Create simulation manager
            sm = proj.factory.simulation_manager()
            
            # Explore to find target string or winning condition
            explore_start = asyncio.get_event_loop().time()
            
            def find_condition(state):
                try:
                    stdout = state.posix.dumps(1)  # stdout
                    return target in stdout
                except:
                    return False
            
            def avoid_condition(state):
                try:
                    stdout = state.posix.dumps(1)
                    return b"fail" in stdout or b"wrong" in stdout or b"invalid" in stdout
                except:
                    return False
            
            # Run exploration with timeout
            sm.explore(find=find_condition, avoid=avoid_condition)
            
            if sm.found:
                self.logger.info("Found winning path via symbolic execution!")
                exploit_state = sm.found[0]
                
                try:
                    # Extract the input that leads to success
                    winning_input = exploit_state.posix.dumps(0)  # stdin
                    
                    # Try to extract any flag-like output
                    output = exploit_state.posix.dumps(1)  # stdout
                    
                    return {
                        "status": "pwned",
                        "method": "symbolic_execution",
                        "winning_input": winning_input.hex() if winning_input else None,
                        "output": output.decode('utf-8', errors='ignore') if output else None,
                        "payload_size": len(winning_input) if winning_input else 0
                    }
                except Exception as e:
                    self.logger.warning(f"Could not extract exploit details: {e}")
                    return {
                        "status": "pwned",
                        "method": "symbolic_execution",
                        "note": "Found winning condition but could not extract payload"
                    }
            else:
                return {
                    "status": "no_path_found",
                    "method": "symbolic_execution",
                    "deadended": len(sm.deadended),
                    "errored": len(sm.errored)
                }
                
        except Exception as e:
            return {
                "status": "symbolic_error", 
                "error": str(e),
                "method": "symbolic_execution"
            }
    
    async def _fuzzing_approach(self, binary_path: str, timeout: int) -> Dict[str, Any]:
        """Use fuzzing to find buffer overflows and crashes."""
        try:
            self.logger.info("Starting fuzzing approach...")
            
            results = {
                "method": "fuzzing",
                "crashes": [],
                "interesting_inputs": []
            }
            
            # Generate various payloads
            payloads = []
            
            # Cyclic patterns for buffer overflows
            for size in [100, 200, 500, 1000, 2000, 4000]:
                try:
                    payload = cyclic(size)
                    payloads.append(("cyclic", size, payload))
                except:
                    payload = b"A" * size
                    payloads.append(("pattern", size, payload))
            
            # Format string payloads
            format_payloads = [b"%x" * 20, b"%s" * 10, b"%n" * 5, b"%p" * 15]
            for payload in format_payloads:
                payloads.append(("format_string", len(payload), payload))
            
            # Integer overflow payloads
            int_payloads = [b"4294967295", b"-1", b"2147483647", b"-2147483648"]
            for payload in int_payloads:
                payloads.append(("integer", len(payload), payload))
            
            crash_count = 0
            for payload_type, size, payload in payloads:
                try:
                    # Run the binary with the payload
                    with tempfile.NamedTemporaryFile(delete=False) as tmp:
                        tmp.write(payload)
                        tmp.flush()
                        
                        # Try different input methods
                        for input_method in ["stdin", "argv", "file"]:
                            try:
                                if input_method == "stdin":
                                    proc = subprocess.run(
                                        [binary_path],
                                        input=payload,
                                        capture_output=True,
                                        timeout=5
                                    )
                                elif input_method == "argv":
                                    proc = subprocess.run(
                                        [binary_path, payload.decode('utf-8', errors='ignore')],
                                        capture_output=True,
                                        timeout=5
                                    )
                                else:  # file
                                    proc = subprocess.run(
                                        [binary_path, tmp.name],
                                        capture_output=True,
                                        timeout=5
                                    )
                                
                                # Check for crashes (segfault, etc.)
                                if proc.returncode < 0:  # Killed by signal
                                    crash_info = {
                                        "payload_type": payload_type,
                                        "payload_size": size,
                                        "input_method": input_method,
                                        "signal": -proc.returncode,
                                        "payload_hex": payload[:100].hex()  # First 100 bytes
                                    }
                                    results["crashes"].append(crash_info)
                                    crash_count += 1
                                    
                                    self.logger.info(f"Crash found! Signal: {-proc.returncode}, Method: {input_method}")
                                
                                # Check for interesting output
                                if proc.stdout and (b"flag" in proc.stdout or b"win" in proc.stdout):
                                    results["interesting_inputs"].append({
                                        "payload_type": payload_type,
                                        "payload_size": size,
                                        "input_method": input_method,
                                        "output": proc.stdout.decode('utf-8', errors='ignore')[:500]
                                    })
                            
                            except subprocess.TimeoutExpired:
                                # Timeout might indicate infinite loop or hang
                                pass
                            except Exception:
                                # Other errors, continue
                                pass
                        
                        os.unlink(tmp.name)
                
                except Exception:
                    continue
            
            if crash_count > 0:
                results["status"] = "crashes_found"
                return results
            elif results["interesting_inputs"]:
                results["status"] = "interesting_behavior"
                return results
            else:
                results["status"] = "no_crashes"
                return results
                
        except Exception as e:
            return {
                "status": "fuzzing_error",
                "error": str(e),
                "method": "fuzzing"
            }
    
    async def _pattern_analysis(self, binary_path: str) -> Dict[str, Any]:
        """Analyze binary for common vulnerability patterns."""
        try:
            self.logger.info("Starting pattern analysis...")
            
            # Static analysis using objdump and strings
            vulnerabilities = []
            
            # Check for dangerous functions
            dangerous_funcs = [
                "gets", "strcpy", "strcat", "sprintf", "scanf", 
                "vsprintf", "strncpy", "strncat", "system",
                "exec", "popen", "fopen"
            ]
            
            try:
                # Use objdump to check for dangerous function calls
                objdump_result = subprocess.run(
                    ["objdump", "-t", binary_path],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                if objdump_result.returncode == 0:
                    for func in dangerous_funcs:
                        if func in objdump_result.stdout:
                            vulnerabilities.append({
                                "type": "dangerous_function",
                                "function": func,
                                "severity": "high" if func in ["gets", "system", "exec"] else "medium"
                            })
            except:
                pass
            
            # Check strings for interesting patterns
            try:
                strings_result = subprocess.run(
                    ["strings", binary_path],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                if strings_result.returncode == 0:
                    strings_output = strings_result.stdout
                    
                    # Look for format string vulnerabilities
                    if "%s" in strings_output or "%x" in strings_output or "%n" in strings_output:
                        vulnerabilities.append({
                            "type": "format_string_pattern",
                            "severity": "high"
                        })
                    
                    # Look for hardcoded credentials or flags
                    lines = strings_output.split('\n')
                    for line in lines:
                        if any(keyword in line.lower() for keyword in ["password", "secret", "key", "flag", "admin"]):
                            vulnerabilities.append({
                                "type": "sensitive_string",
                                "content": line[:100],  # Limit length
                                "severity": "medium"
                            })
            except:
                pass
            
            return {
                "status": "pattern_analysis_complete",
                "method": "pattern_analysis",
                "vulnerabilities": vulnerabilities,
                "vulnerability_count": len(vulnerabilities)
            }
            
        except Exception as e:
            return {
                "status": "pattern_error",
                "error": str(e),
                "method": "pattern_analysis"
            }
