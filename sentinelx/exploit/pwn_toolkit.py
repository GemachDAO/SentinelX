from __future__ import annotations
import asyncio
import os
from typing import Dict, Any, List, Optional
from ..core.task import Task

try:
    from pwn import *
    PWN_AVAILABLE = True
except ImportError:
    PWN_AVAILABLE = False


class PwnToolkit(Task):
    """Comprehensive pwn toolkit that combines all exploitation techniques."""
    
    async def validate_params(self) -> None:
        """Validate PwnToolkit parameters."""
        if not PWN_AVAILABLE:
            raise ValueError("pwntools is required. Install with: pip install pwntools")
        
        if not self.params.get("binary"):
            raise ValueError("binary parameter is required")
            
        binary_path = self.params["binary"]
        if not os.path.exists(binary_path):
            raise ValueError(f"Binary file not found: {binary_path}")
    
    async def run(self) -> Dict[str, Any]:
        """Run comprehensive pwn analysis and exploitation."""
        await self.validate_params()
        
        binary_path = self.params["binary"]
        mode = self.params.get("mode", "full")  # full, quick, custom
        techniques = self.params.get("techniques", [])  # specific techniques to try
        libc_path = self.params.get("libc")
        
        results = {
            "binary": binary_path,
            "mode": mode,
            "status": "analyzing",
            "summary": {},
            "exploits": {}
        }
        
        try:
            # Load binary
            elf = ELF(binary_path)
            
            results["binary_info"] = {
                "arch": elf.arch,
                "bits": elf.bits,
                "endian": elf.endian,
                "canary": elf.canary,
                "nx": elf.nx,
                "pie": elf.pie,
                "relro": elf.relro,
                "symbols": list(elf.symbols.keys())[:20]  # First 20 symbols
            }
            
            self.logger.info(f"🎯 Starting comprehensive pwn analysis of {binary_path}")
            self.logger.info(f"📊 Binary: {elf.arch} {elf.bits}-bit, Protections: NX={elf.nx}, PIE={elf.pie}, Canary={elf.canary}")
            
            # Step 1: Basic vulnerability scanning
            vuln_scan = await self._vulnerability_scan(elf)
            results["vulnerability_scan"] = vuln_scan
            
            # Step 2: Try exploitation techniques based on mode
            if mode == "quick":
                exploit_results = await self._quick_exploitation(elf, libc_path)
            elif mode == "custom" and techniques:
                exploit_results = await self._custom_exploitation(elf, techniques, libc_path)
            else:  # full mode
                exploit_results = await self._full_exploitation(elf, libc_path)
            
            results["exploits"] = exploit_results
            
            # Step 3: Generate summary and recommendations
            summary = await self._generate_summary(results)
            results["summary"] = summary
            
            results["status"] = "complete"
            
            # Log summary
            self._log_summary(summary)
            
            return results
            
        except Exception as e:
            self.logger.error(f"PwnToolkit analysis failed: {e}")
            return {
                "status": "error",
                "error": str(e),
                "binary": binary_path
            }
    
    async def _vulnerability_scan(self, elf) -> Dict[str, Any]:
        """Scan for common vulnerability patterns."""
        from .exploit_gen import AutoPwn
        
        try:
            self.logger.info("🔍 Running vulnerability scan...")
            
            # Use AutoPwn for pattern analysis
            autopwn = AutoPwn(
                params={"binary": elf.path, "strategy": "pattern"},
                logger=self.logger
            )
            
            scan_result = await autopwn.run()
            
            # Enhance with additional checks
            additional_checks = {
                "dangerous_functions": self._check_dangerous_functions(elf),
                "writable_segments": self._check_writable_segments(elf),
                "interesting_strings": self._check_interesting_strings(elf)
            }
            
            scan_result.update(additional_checks)
            return scan_result
            
        except Exception as e:
            return {
                "status": "scan_error",
                "error": str(e)
            }
    
    async def _quick_exploitation(self, elf, libc_path: Optional[str]) -> Dict[str, Any]:
        """Quick exploitation attempt with most common techniques."""
        techniques_to_try = ["buffer_overflow", "format_string", "double_free"]
        return await self._try_techniques(elf, techniques_to_try, libc_path)
    
    async def _custom_exploitation(self, elf, techniques: List[str], libc_path: Optional[str]) -> Dict[str, Any]:
        """Try user-specified exploitation techniques."""
        return await self._try_techniques(elf, techniques, libc_path)
    
    async def _full_exploitation(self, elf, libc_path: Optional[str]) -> Dict[str, Any]:
        """Full exploitation analysis with all available techniques."""
        all_techniques = [
            "buffer_overflow", "rop_chain", "ret2libc", "format_string", 
            "shellcode_injection", "fastbin_dup", "tcache_poison", 
            "house_of_spirit", "unsorted_bin", "double_free"
        ]
        return await self._try_techniques(elf, all_techniques, libc_path)
    
    async def _try_techniques(self, elf, techniques: List[str], libc_path: Optional[str]) -> Dict[str, Any]:
        """Try multiple exploitation techniques."""
        exploit_results = {}
        
        for technique in techniques:
            try:
                self.logger.info(f"🔧 Trying {technique} exploitation...")
                
                if technique in ["buffer_overflow", "ret2libc", "shellcode_injection"]:
                    result = await self._try_binary_exploit(elf, technique)
                elif technique == "rop_chain":
                    result = await self._try_rop_exploit(elf, libc_path)
                elif technique == "format_string":
                    result = await self._try_format_string(elf)
                elif technique in ["fastbin_dup", "tcache_poison", "house_of_spirit", "unsorted_bin", "double_free"]:
                    result = await self._try_heap_exploit(elf, technique, libc_path)
                else:
                    result = {"status": "technique_not_implemented", "technique": technique}
                
                exploit_results[technique] = result
                
                # If we found a working exploit, highlight it
                if result.get("status") in ["overflow_found", "rop_chains_generated", "format_string_vulnerable", "technique_available"]:
                    self.logger.info(f"✅ {technique} exploitation: POSSIBLE")
                else:
                    self.logger.info(f"❌ {technique} exploitation: Not applicable")
                    
            except Exception as e:
                exploit_results[technique] = {
                    "status": "error",
                    "error": str(e)
                }
                self.logger.warning(f"⚠️  {technique} analysis failed: {e}")
        
        return exploit_results
    
    async def _try_binary_exploit(self, elf, technique: str) -> Dict[str, Any]:
        """Try binary exploitation techniques."""
        from .binary_pwn import BinaryExploit
        
        binary_exploit = BinaryExploit(
            params={"binary": elf.path, "type": technique},
            logger=self.logger
        )
        
        return await binary_exploit.run()
    
    async def _try_rop_exploit(self, elf, libc_path: Optional[str]) -> Dict[str, Any]:
        """Try ROP chain exploitation."""
        from .rop_exploit import ROPExploit
        
        params = {"binary": elf.path, "type": "auto"}
        if libc_path:
            params["libc"] = libc_path
        
        rop_exploit = ROPExploit(params=params, logger=self.logger)
        return await rop_exploit.run()
    
    async def _try_format_string(self, elf) -> Dict[str, Any]:
        """Try format string exploitation."""
        from .binary_pwn import BinaryExploit
        
        binary_exploit = BinaryExploit(
            params={"binary": elf.path, "type": "format_string"},
            logger=self.logger
        )
        
        return await binary_exploit.run()
    
    async def _try_heap_exploit(self, elf, technique: str, libc_path: Optional[str]) -> Dict[str, Any]:
        """Try heap exploitation techniques."""
        from .heap_exploit import HeapExploit
        
        params = {"binary": elf.path, "technique": technique}
        if libc_path:
            params["libc"] = libc_path
        
        heap_exploit = HeapExploit(params=params, logger=self.logger)
        return await heap_exploit.run()
    
    def _check_dangerous_functions(self, elf) -> Dict[str, Any]:
        """Check for dangerous function usage."""
        dangerous_funcs = {
            "critical": ["gets", "strcpy", "sprintf", "system", "exec"],
            "high": ["strcat", "scanf", "vsprintf", "popen"],
            "medium": ["strncpy", "strncat", "fopen", "memcpy"]
        }
        
        found_functions = {"critical": [], "high": [], "medium": []}
        
        for severity, funcs in dangerous_funcs.items():
            for func in funcs:
                if func in elf.symbols:
                    found_functions[severity].append(func)
        
        return {
            "dangerous_functions": found_functions,
            "total_dangerous": sum(len(funcs) for funcs in found_functions.values())
        }
    
    def _check_writable_segments(self, elf) -> Dict[str, Any]:
        """Check for writable segments."""
        writable_segments = []
        
        for segment in elf.segments:
            if segment.header.p_flags & 0x2:  # PF_W (writable)
                writable_segments.append({
                    "address": hex(segment.header.p_vaddr),
                    "size": segment.header.p_memsz,
                    "executable": bool(segment.header.p_flags & 0x1)  # PF_X
                })
        
        return {
            "writable_segments": writable_segments,
            "count": len(writable_segments)
        }
    
    def _check_interesting_strings(self, elf) -> Dict[str, Any]:
        """Check for interesting strings in the binary."""
        import subprocess
        
        interesting_patterns = [
            "flag", "password", "secret", "key", "admin", 
            "/bin/sh", "/bin/bash", "system", "exec"
        ]
        
        found_strings = {}
        
        try:
            result = subprocess.run(
                ["strings", elf.path],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                strings_output = result.stdout.lower()
                
                for pattern in interesting_patterns:
                    if pattern in strings_output:
                        # Find actual strings containing the pattern
                        matching_lines = [
                            line for line in result.stdout.split('\\n') 
                            if pattern in line.lower() and len(line.strip()) > 2
                        ]
                        if matching_lines:
                            found_strings[pattern] = matching_lines[:5]  # First 5 matches
            
        except Exception:
            pass
        
        return {
            "interesting_strings": found_strings,
            "pattern_matches": len(found_strings)
        }
    
    async def _generate_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate analysis summary and recommendations."""
        summary = {
            "vulnerability_assessment": "unknown",
            "exploitability": "unknown",
            "recommended_techniques": [],
            "protection_bypass_required": [],
            "difficulty": "unknown"
        }
        
        try:
            binary_info = results.get("binary_info", {})
            exploits = results.get("exploits", {})
            
            # Assess vulnerability level
            successful_exploits = [
                name for name, result in exploits.items()
                if result.get("status") in ["overflow_found", "rop_chains_generated", "format_string_vulnerable", "technique_available", "chains_available"]
            ]
            
            if len(successful_exploits) >= 3:
                summary["vulnerability_assessment"] = "high"
                summary["exploitability"] = "high"
            elif len(successful_exploits) >= 1:
                summary["vulnerability_assessment"] = "medium"
                summary["exploitability"] = "medium"
            else:
                summary["vulnerability_assessment"] = "low"
                summary["exploitability"] = "low"
            
            # Recommend techniques
            summary["recommended_techniques"] = successful_exploits[:3]  # Top 3
            
            # Assess protection bypass requirements
            protections = []
            if binary_info.get("nx"):
                protections.append("NX (No Execute)")
            if binary_info.get("pie"):
                protections.append("PIE (Position Independent)")
            if binary_info.get("canary"):
                protections.append("Stack Canary")
            if binary_info.get("relro") == "Full":
                protections.append("Full RELRO")
            
            summary["protection_bypass_required"] = protections
            
            # Assess difficulty
            if len(protections) == 0:
                summary["difficulty"] = "easy"
            elif len(protections) <= 2:
                summary["difficulty"] = "medium"
            else:
                summary["difficulty"] = "hard"
            
            # Additional insights
            vuln_scan = results.get("vulnerability_scan", {})
            dangerous_funcs = vuln_scan.get("dangerous_functions", {})
            
            if dangerous_funcs.get("critical"):
                summary["critical_functions"] = dangerous_funcs["critical"]
            
            return summary
            
        except Exception as e:
            summary["error"] = str(e)
            return summary
    
    def _log_summary(self, summary: Dict[str, Any]) -> None:
        """Log a formatted summary of the analysis."""
        self.logger.info("=" * 60)
        self.logger.info("🎯 PWN TOOLKIT ANALYSIS SUMMARY")
        self.logger.info("=" * 60)
        
        vulnerability = summary.get("vulnerability_assessment", "unknown").upper()
        exploitability = summary.get("exploitability", "unknown").upper()
        difficulty = summary.get("difficulty", "unknown").upper()
        
        self.logger.info(f"📊 Vulnerability Level: {vulnerability}")
        self.logger.info(f"🎯 Exploitability: {exploitability}")
        self.logger.info(f"⚡ Difficulty: {difficulty}")
        
        recommended = summary.get("recommended_techniques", [])
        if recommended:
            self.logger.info(f"✅ Recommended Techniques: {', '.join(recommended)}")
        
        protections = summary.get("protection_bypass_required", [])
        if protections:
            self.logger.info(f"🛡️  Protections to Bypass: {', '.join(protections)}")
        
        critical_funcs = summary.get("critical_functions", [])
        if critical_funcs:
            self.logger.info(f"⚠️  Critical Functions Found: {', '.join(critical_funcs)}")
        
        self.logger.info("=" * 60)
