from __future__ import annotations
import subprocess
import tempfile
import os
import struct
from typing import Dict, Any, List, Optional, Tuple
from ..core.task import Task

try:
    from pwn import *
    PWN_AVAILABLE = True
except ImportError:
    PWN_AVAILABLE = False


class HeapExploit(Task):
    """Advanced heap exploitation techniques for modern malloc implementations."""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.heap_info = {}
        
    async def validate_params(self) -> None:
        """Validate heap exploitation parameters."""
        if not PWN_AVAILABLE:
            raise ValueError("pwntools is required. Install with: pip install pwntools")
        
        if not self.params.get("binary"):
            raise ValueError("binary parameter is required")
            
        binary_path = self.params["binary"]
        if not os.path.exists(binary_path):
            raise ValueError(f"Binary file not found: {binary_path}")
    
    async def run(self) -> Dict[str, Any]:
        """Analyze and exploit heap vulnerabilities."""
        await self.validate_params()
        
        binary_path = self.params["binary"]
        technique = self.params.get("technique", "auto")
        libc_path = self.params.get("libc")
        
        results = {
            "binary": binary_path,
            "technique": technique,
            "status": "analyzing"
        }
        
        try:
            # Load binary and libc
            elf = ELF(binary_path)
            libc = None
            if libc_path and os.path.exists(libc_path):
                libc = ELF(libc_path)
                results["libc"] = libc_path
            
            # Analyze heap configuration
            heap_analysis = await self._analyze_heap_config(elf, libc)
            results["heap_analysis"] = heap_analysis
            
            self.logger.info(f"Heap exploitation analysis for {elf.arch} binary")
            
            # Execute heap exploitation technique
            if technique == "fastbin_dup":
                exploit_result = await self._fastbin_dup_exploit(elf, libc)
            elif technique == "unsorted_bin":
                exploit_result = await self._unsorted_bin_exploit(elf, libc)
            elif technique == "tcache_poison":
                exploit_result = await self._tcache_poisoning(elf, libc)
            elif technique == "house_of_spirit":
                exploit_result = await self._house_of_spirit(elf, libc)
            elif technique == "house_of_orange":
                exploit_result = await self._house_of_orange(elf, libc)
            elif technique == "house_of_einherjar":
                exploit_result = await self._house_of_einherjar(elf, libc)
            elif technique == "double_free":
                exploit_result = await self._double_free_exploit(elf, libc)
            else:
                # Auto mode - detect and try applicable techniques
                exploit_result = await self._auto_heap_exploit(elf, libc)
            
            results.update(exploit_result)
            return results
            
        except Exception as e:
            self.logger.error(f"Heap exploitation failed: {e}")
            return {
                "status": "error",
                "error": str(e),
                "binary": binary_path
            }
    
    async def _analyze_heap_config(self, elf, libc) -> Dict[str, Any]:
        """Analyze heap configuration and malloc implementation."""
        analysis = {
            "malloc_implementation": "unknown",
            "heap_protections": [],
            "chunk_sizes": {},
            "available_functions": []
        }
        
        try:
            # Check for heap-related symbols
            heap_functions = [
                "malloc", "free", "calloc", "realloc", 
                "__libc_malloc", "__libc_free", "malloc_hook", "free_hook"
            ]
            
            for func in heap_functions:
                if func in elf.symbols:
                    analysis["available_functions"].append(func)
                elif libc and func in libc.symbols:
                    analysis["available_functions"].append(f"{func} (libc)")
            
            # Detect libc version and malloc implementation
            if libc:
                # Try to determine glibc version
                try:
                    with open(libc.path, 'rb') as f:
                        libc_data = f.read()
                        if b"glibc" in libc_data:
                            analysis["malloc_implementation"] = "glibc"
                            
                            # Check for tcache (glibc 2.26+)
                            if b"tcache" in libc_data:
                                analysis["heap_protections"].append("tcache")
                            
                            # Check for safe linking (glibc 2.32+)
                            if b"safe" in libc_data and b"link" in libc_data:
                                analysis["heap_protections"].append("safe_linking")
                                
                        elif b"musl" in libc_data:
                            analysis["malloc_implementation"] = "musl"
                        elif b"jemalloc" in libc_data:
                            analysis["malloc_implementation"] = "jemalloc"
                            
                except Exception:
                    pass
            
            # Standard chunk sizes for glibc
            if analysis["malloc_implementation"] == "glibc":
                if elf.bits == 64:
                    analysis["chunk_sizes"] = {
                        "min_chunk": 32,
                        "fastbin_max": 128,
                        "tcache_max": 1032,
                        "smallbin_max": 1024,
                        "largebin_min": 1024
                    }
                else:
                    analysis["chunk_sizes"] = {
                        "min_chunk": 16,
                        "fastbin_max": 64,
                        "tcache_max": 516,
                        "smallbin_max": 512,
                        "largebin_min": 512
                    }
            
            # Check for heap canaries/guards
            if elf.canary:
                analysis["heap_protections"].append("stack_canary")
            
            # Check for FORTIFY_SOURCE
            try:
                result = subprocess.run(
                    ["readelf", "-s", elf.path],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                if "__chk" in result.stdout:
                    analysis["heap_protections"].append("fortify_source")
            except:
                pass
            
            return analysis
            
        except Exception as e:
            analysis["error"] = str(e)
            return analysis
    
    async def _fastbin_dup_exploit(self, elf, libc) -> Dict[str, Any]:
        """Fastbin duplication attack."""
        try:
            self.logger.info("Analyzing fastbin duplication vulnerability")
            
            exploit_info = {
                "technique": "fastbin_dup",
                "status": "analyzing",
                "requirements": [
                    "Ability to free the same chunk twice",
                    "Fastbin size chunk (< 128 bytes on x64)",
                    "Control over malloc size parameter"
                ]
            }
            
            # Check if binary uses fastbin-sized allocations
            fastbin_sizes = [16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128]
            
            exploit_info["target_sizes"] = fastbin_sizes
            
            # Generate exploitation steps
            steps = [
                "1. Allocate chunk A of fastbin size",
                "2. Allocate chunk B (to prevent consolidation)",
                "3. Free chunk A",
                "4. Free chunk A again (double free)",
                "5. Allocate chunk C (gets A)",
                "6. Allocate chunk D (gets A again)",
                "7. Now C and D point to same memory - use after free"
            ]
            
            exploit_info["exploitation_steps"] = steps
            
            # Check for double-free protections
            protections = []
            if "tcache" in self.heap_info.get("heap_protections", []):
                protections.append("tcache_double_free_check")
            if "safe_linking" in self.heap_info.get("heap_protections", []):
                protections.append("safe_linking")
            
            exploit_info["protections_to_bypass"] = protections
            
            # Generate sample payload
            if elf.bits == 64:
                sample_payload = {
                    "chunk_size": 0x40,  # 64 bytes
                    "fake_chunk_addr": 0x601000,  # Example target address
                    "payload_description": "Overwrite fastbin fd pointer to target"
                }
            else:
                sample_payload = {
                    "chunk_size": 0x20,  # 32 bytes
                    "fake_chunk_addr": 0x804a000,  # Example target address
                    "payload_description": "Overwrite fastbin fd pointer to target"
                }
            
            exploit_info["sample_payload"] = sample_payload
            exploit_info["status"] = "technique_available"
            
            return exploit_info
            
        except Exception as e:
            return {
                "technique": "fastbin_dup",
                "status": "error",
                "error": str(e)
            }
    
    async def _tcache_poisoning(self, elf, libc) -> Dict[str, Any]:
        """Tcache poisoning attack (glibc 2.26+)."""
        try:
            self.logger.info("Analyzing tcache poisoning vulnerability")
            
            exploit_info = {
                "technique": "tcache_poisoning",
                "status": "analyzing",
                "requirements": [
                    "glibc 2.26+ with tcache",
                    "Use after free or double free",
                    "Control over malloc size parameter"
                ]
            }
            
            # Check if tcache is available
            if "tcache" not in self.heap_info.get("heap_protections", []):
                exploit_info["status"] = "tcache_not_available"
                exploit_info["error"] = "Tcache not detected in this libc version"
                return exploit_info
            
            # Tcache bins for different sizes
            tcache_sizes = list(range(24, 1032, 16)) if elf.bits == 64 else list(range(12, 516, 8))
            exploit_info["tcache_sizes"] = tcache_sizes[:20]  # Show first 20
            
            # Exploitation steps
            steps = [
                "1. Allocate chunk A of tcache size",
                "2. Free chunk A (goes to tcache)",
                "3. Use after free to overwrite A's next pointer",
                "4. Point next to target address",
                "5. Allocate chunk B (gets A from tcache)",
                "6. Allocate chunk C (gets target address)"
            ]
            
            exploit_info["exploitation_steps"] = steps
            
            # Check for tcache protections
            protections = []
            if "safe_linking" in self.heap_info.get("heap_protections", []):
                protections.append("safe_linking_in_tcache")
                exploit_info["bypass_note"] = "Safe linking requires heap address leak"
            
            exploit_info["protections_to_bypass"] = protections
            
            # Sample target addresses
            targets = {
                "__malloc_hook": "Overwrite malloc hook for code execution",
                "__free_hook": "Overwrite free hook for code execution", 
                "global_variable": "Overwrite global variables",
                "stack_address": "Arbitrary stack write (needs leak)"
            }
            
            exploit_info["potential_targets"] = targets
            exploit_info["status"] = "technique_available"
            
            return exploit_info
            
        except Exception as e:
            return {
                "technique": "tcache_poisoning",
                "status": "error",
                "error": str(e)
            }
    
    async def _house_of_spirit(self, elf, libc) -> Dict[str, Any]:
        """House of Spirit technique."""
        try:
            self.logger.info("Analyzing House of Spirit vulnerability")
            
            exploit_info = {
                "technique": "house_of_spirit",
                "status": "analyzing",
                "requirements": [
                    "Control over a pointer that gets freed",
                    "Ability to fake chunk metadata",
                    "Stack or global memory for fake chunk"
                ]
            }
            
            # Chunk header requirements
            if elf.bits == 64:
                chunk_requirements = {
                    "prev_size": "Previous chunk size (if prev_inuse=0)",
                    "size": "Chunk size with flags (must be valid fastbin/tcache size)",
                    "next_chunk_size": "Next chunk must have valid size field",
                    "alignment": "16-byte aligned address"
                }
            else:
                chunk_requirements = {
                    "prev_size": "Previous chunk size (if prev_inuse=0)",
                    "size": "Chunk size with flags (must be valid fastbin/tcache size)",
                    "next_chunk_size": "Next chunk must have valid size field",
                    "alignment": "8-byte aligned address"
                }
            
            exploit_info["chunk_requirements"] = chunk_requirements
            
            # Exploitation steps
            steps = [
                "1. Create fake chunk on stack/global memory",
                "2. Set fake chunk size to valid fastbin/tcache size",
                "3. Ensure next chunk has valid size field",
                "4. Get pointer to fake chunk passed to free()",
                "5. free() will put fake chunk in fastbin/tcache",
                "6. malloc() will return pointer to controlled memory"
            ]
            
            exploit_info["exploitation_steps"] = steps
            
            # Generate fake chunk template
            if elf.bits == 64:
                fake_chunk = {
                    "offset_0": "0x0000000000000000",  # prev_size (optional)
                    "offset_8": "0x0000000000000041",   # size (0x40 + PREV_INUSE)
                    "offset_16": "target_data_here",
                    "offset_64": "0x0000000000000040",  # next chunk size
                }
            else:
                fake_chunk = {
                    "offset_0": "0x00000000",  # prev_size (optional)
                    "offset_4": "0x00000021",  # size (0x20 + PREV_INUSE)
                    "offset_8": "target_data_here",
                    "offset_32": "0x00000020",  # next chunk size
                }
            
            exploit_info["fake_chunk_template"] = fake_chunk
            exploit_info["status"] = "technique_available"
            
            return exploit_info
            
        except Exception as e:
            return {
                "technique": "house_of_spirit",
                "status": "error",
                "error": str(e)
            }
    
    async def _house_of_orange(self, elf, libc) -> Dict[str, Any]:
        """House of Orange technique (file structure exploitation)."""
        try:
            self.logger.info("Analyzing House of Orange vulnerability")
            
            exploit_info = {
                "technique": "house_of_orange",
                "status": "analyzing",
                "requirements": [
                    "Ability to corrupt top chunk size",
                    "malloc() call that triggers __malloc_assert",
                    "Control over _IO_list_all or _IO_FILE structure"
                ]
            }
            
            # Check for required symbols
            required_symbols = ["_IO_list_all", "_IO_flush_all_lockp", "malloc_printerr"]
            available_symbols = []
            
            for symbol in required_symbols:
                if libc and symbol in libc.symbols:
                    available_symbols.append(symbol)
            
            exploit_info["available_symbols"] = available_symbols
            
            if len(available_symbols) < len(required_symbols):
                exploit_info["status"] = "missing_symbols"
                exploit_info["missing"] = [s for s in required_symbols if s not in available_symbols]
                return exploit_info
            
            # Exploitation steps
            steps = [
                "1. Corrupt top chunk size to invalid value",
                "2. Trigger malloc() that causes top chunk extension failure",
                "3. This calls malloc_printerr() which calls _IO_flush_all_lockp()",
                "4. _IO_flush_all_lockp() iterates through _IO_list_all",
                "5. Corrupt _IO_list_all to point to fake _IO_FILE",
                "6. Fake _IO_FILE structure hijacks control flow"
            ]
            
            exploit_info["exploitation_steps"] = steps
            
            # _IO_FILE structure template
            io_file_template = {
                "offset_0": "_flags (set to trigger vulnerability)",
                "offset_8": "_IO_read_ptr",
                "offset_16": "_IO_read_end", 
                "offset_24": "_IO_read_base",
                # ... many more fields
                "offset_216": "_IO_FILE_plus vtable pointer (target)",
                "note": "Full _IO_FILE structure is ~200 bytes"
            }
            
            exploit_info["io_file_template"] = io_file_template
            exploit_info["status"] = "technique_available"
            exploit_info["complexity"] = "high"
            
            return exploit_info
            
        except Exception as e:
            return {
                "technique": "house_of_orange",
                "status": "error",
                "error": str(e)
            }
    
    async def _house_of_einherjar(self, elf, libc) -> Dict[str, Any]:
        """House of Einherjar technique (off-by-one null byte)."""
        try:
            self.logger.info("Analyzing House of Einherjar vulnerability")
            
            exploit_info = {
                "technique": "house_of_einherjar",
                "status": "analyzing",
                "requirements": [
                    "Off-by-one null byte write",
                    "Ability to control chunk content",
                    "malloc() and free() primitives"
                ]
            }
            
            # Exploitation steps
            steps = [
                "1. Allocate chunk A (victim)",
                "2. Allocate chunk B (to prevent consolidation)",
                "3. Use off-by-one to clear PREV_INUSE bit of chunk B",
                "4. Fake prev_size field in chunk A to point to fake chunk",
                "5. Free chunk B - triggers backward consolidation",
                "6. Consolidation uses fake prev_size, extending free chunk",
                "7. Next malloc() can return overlapping chunks"
            ]
            
            exploit_info["exploitation_steps"] = steps
            
            # Chunk layout visualization
            layout = {
                "chunk_A": "Controlled chunk with fake prev_size",
                "chunk_B": "Victim chunk with corrupted PREV_INUSE bit",
                "fake_prev_size": "Points to fake chunk before chunk_A",
                "result": "Free chunk spans from fake chunk to chunk_B"
            }
            
            exploit_info["chunk_layout"] = layout
            
            # Requirements for bypassing modern protections
            modern_requirements = [
                "Heap address leak (for safe linking bypass)",
                "Careful chunk size crafting",
                "Valid chunk boundaries for consolidation"
            ]
            
            exploit_info["modern_requirements"] = modern_requirements
            exploit_info["status"] = "technique_available"
            exploit_info["difficulty"] = "medium"
            
            return exploit_info
            
        except Exception as e:
            return {
                "technique": "house_of_einherjar",
                "status": "error",
                "error": str(e)
            }
    
    async def _unsorted_bin_exploit(self, elf, libc) -> Dict[str, Any]:
        """Unsorted bin attack technique."""
        try:
            self.logger.info("Analyzing unsorted bin attack")
            
            exploit_info = {
                "technique": "unsorted_bin",
                "status": "analyzing",
                "requirements": [
                    "Large chunk allocation and free (> fastbin size)",
                    "Use after free to corrupt unsorted bin",
                    "Target writable address"
                ]
            }
            
            # Exploitation steps
            steps = [
                "1. Allocate large chunk (goes to unsorted bin when freed)",
                "2. Free the chunk",
                "3. Use after free to corrupt bk pointer of unsorted bin chunk",
                "4. Point bk to (target - 0x10)",
                "5. Next malloc() will write main_arena address to target"
            ]
            
            exploit_info["exploitation_steps"] = steps
            
            # Calculate chunk sizes for unsorted bin
            if elf.bits == 64:
                min_size = 0x420  # Larger than fastbin and tcache
                exploit_info["min_chunk_size"] = min_size
            else:
                min_size = 0x200
                exploit_info["min_chunk_size"] = min_size
            
            # Potential targets
            targets = {
                "global_max_fast": "Increase fastbin size limit",
                "__malloc_hook": "Overwrite malloc hook (partial write)",
                "stack_variable": "Overwrite stack variable (needs leak)",
                "bss_variable": "Overwrite global variable"
            }
            
            exploit_info["potential_targets"] = targets
            exploit_info["status"] = "technique_available"
            
            return exploit_info
            
        except Exception as e:
            return {
                "technique": "unsorted_bin",
                "status": "error",
                "error": str(e)
            }
    
    async def _double_free_exploit(self, elf, libc) -> Dict[str, Any]:
        """Double free vulnerability analysis."""
        try:
            self.logger.info("Analyzing double free vulnerability")
            
            exploit_info = {
                "technique": "double_free",
                "status": "analyzing",
                "requirements": [
                    "Ability to call free() twice on same chunk",
                    "Control over malloc() calls",
                    "Target for arbitrary write"
                ]
            }
            
            # Different double free scenarios
            scenarios = {
                "fastbin_double_free": "Classic double free in fastbin",
                "tcache_double_free": "Double free in tcache (easier)",
                "delayed_double_free": "Free other chunks between double free"
            }
            
            exploit_info["scenarios"] = scenarios
            
            # Check protections
            protections = []
            if "tcache" in self.heap_info.get("heap_protections", []):
                protections.append("tcache_double_free_check (glibc 2.29+)")
            if "safe_linking" in self.heap_info.get("heap_protections", []):
                protections.append("safe_linking (requires heap leak)")
            
            exploit_info["protections"] = protections
            
            # Basic exploitation
            basic_steps = [
                "1. Allocate chunk A",
                "2. Free chunk A",
                "3. Free chunk A again (double free)",
                "4. Allocate chunk B (gets A)",
                "5. Overwrite A's fd pointer through B",
                "6. Allocate chunk C (gets A again)",
                "7. Allocate chunk D (gets target address)"
            ]
            
            exploit_info["basic_steps"] = basic_steps
            exploit_info["status"] = "technique_available"
            
            return exploit_info
            
        except Exception as e:
            return {
                "technique": "double_free",
                "status": "error",
                "error": str(e)
            }
    
    async def _auto_heap_exploit(self, elf, libc) -> Dict[str, Any]:
        """Automatically detect and suggest heap exploitation techniques."""
        try:
            self.logger.info("Auto-detecting applicable heap exploitation techniques")
            
            auto_results = {
                "method": "auto_heap",
                "applicable_techniques": [],
                "recommended": None
            }
            
            # Store heap info for other methods
            self.heap_info = await self._analyze_heap_config(elf, libc)
            
            # Test each technique
            techniques = [
                "fastbin_dup", "tcache_poison", "double_free", 
                "house_of_spirit", "unsorted_bin", "house_of_einherjar", "house_of_orange"
            ]
            
            for technique in techniques:
                try:
                    if technique == "fastbin_dup":
                        result = await self._fastbin_dup_exploit(elf, libc)
                    elif technique == "tcache_poison":
                        result = await self._tcache_poisoning(elf, libc)
                    elif technique == "double_free":
                        result = await self._double_free_exploit(elf, libc)
                    elif technique == "house_of_spirit":
                        result = await self._house_of_spirit(elf, libc)
                    elif technique == "unsorted_bin":
                        result = await self._unsorted_bin_exploit(elf, libc)
                    elif technique == "house_of_einherjar":
                        result = await self._house_of_einherjar(elf, libc)
                    elif technique == "house_of_orange":
                        result = await self._house_of_orange(elf, libc)
                    
                    if result.get("status") == "technique_available":
                        auto_results["applicable_techniques"].append({
                            "technique": technique,
                            "difficulty": result.get("difficulty", "medium"),
                            "requirements": result.get("requirements", [])
                        })
                        
                        # Recommend easiest/most reliable technique
                        if not auto_results["recommended"]:
                            if technique in ["tcache_poison", "double_free", "fastbin_dup"]:
                                auto_results["recommended"] = technique
                        
                except Exception as e:
                    self.logger.warning(f"Technique {technique} analysis failed: {e}")
                    continue
            
            auto_results["heap_info"] = self.heap_info
            auto_results["status"] = "analysis_complete"
            
            if not auto_results["applicable_techniques"]:
                auto_results["status"] = "no_techniques_applicable"
            
            return auto_results
            
        except Exception as e:
            return {
                "method": "auto_heap",
                "status": "error",
                "error": str(e)
            }
